   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"usb.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.usbStatusIn,"ax",%progbits
  16              		.align	1
  17              		.global	usbStatusIn
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	usbStatusIn:
  25              	.LFB11:
  26              		.file 1 "usb.c"
   1:usb.c         **** /* *****************************************************************************
   2:usb.c         ****  * The MIT License
   3:usb.c         ****  *
   4:usb.c         ****  * Copyright (c) 2010 LeafLabs LLC.
   5:usb.c         ****  *
   6:usb.c         ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:usb.c         ****  * of this software and associated documentation files (the "Software"), to deal
   8:usb.c         ****  * in the Software without restriction, including without limitation the rights
   9:usb.c         ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:usb.c         ****  * copies of the Software, and to permit persons to whom the Software is
  11:usb.c         ****  * furnished to do so, subject to the following conditions:
  12:usb.c         ****  *
  13:usb.c         ****  * The above copyright notice and this permission notice shall be included in
  14:usb.c         ****  * all copies or substantial portions of the Software.
  15:usb.c         ****  *
  16:usb.c         ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:usb.c         ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:usb.c         ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:usb.c         ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:usb.c         ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:usb.c         ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:usb.c         ****  * THE SOFTWARE.
  23:usb.c         ****  * ****************************************************************************/
  24:usb.c         **** 
  25:usb.c         **** /**
  26:usb.c         ****  *  @file usb.c
  27:usb.c         ****  *
  28:usb.c         ****  *  @brief usb-specific hardware setup, NVIC, clocks, and usb activities
  29:usb.c         ****  *  in the pre-attached state. includes some of the lower level callbacks
  30:usb.c         ****  *  needed by the usb library, like suspend,resume,init,etc
  31:usb.c         ****  */
  32:usb.c         **** 
  33:usb.c         **** #include "usb.h"
  34:usb.c         **** #include "dfu.h"
  35:usb.c         **** int wTransferSize;
  36:usb.c         **** 
  37:usb.c         **** extern u8 u8_usbConfigDescriptorDFU[];
  38:usb.c         **** extern u8 u8_usbFunctionalDescriptor[];
  39:usb.c         **** 
  40:usb.c         **** void setupUSB (void) {
  41:usb.c         **** 
  42:usb.c         **** #ifdef HAS_MAPLE_HARDWARE
  43:usb.c         ****     /* Setup USB DISC pin as output open drain */
  44:usb.c         ****     SET_REG(GPIO_CR(USB_DISC_BANK,USB_DISC_PIN),(GET_REG(GPIO_CR(USB_DISC_BANK,USB_DISC_PIN)) & crM
  45:usb.c         ****     gpio_write_bit(USB_DISC_BANK,USB_DISC_PIN,1);
  46:usb.c         **** 
  47:usb.c         ****     /* turn on the USB clock */
  48:usb.c         ****     //pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;// done in setupCLK()
  49:usb.c         **** 
  50:usb.c         ****     gpio_write_bit(USB_DISC_BANK,USB_DISC_PIN,0);  /* present ourselves to the host */
  51:usb.c         **** #else
  52:usb.c         **** 
  53:usb.c         **** /* Generic boards don't have disconnect hardware, so we drive PA12 which is connected to the usb D+
  54:usb.c         **** #define USB_DISC_BANK         GPIOA
  55:usb.c         **** #define USB_DISC_PIN              12
  56:usb.c         **** 
  57:usb.c         ****     SET_REG(GPIO_CR(USB_DISC_BANK,USB_DISC_PIN),(GET_REG(GPIO_CR(USB_DISC_BANK,USB_DISC_PIN)) & crM
  58:usb.c         **** 
  59:usb.c         ****     gpio_write_bit(USB_DISC_BANK,USB_DISC_PIN,0);  /* present ourselves to the host */
  60:usb.c         **** 
  61:usb.c         ****     volatile unsigned int delay;
  62:usb.c         ****     for(delay = 0;delay<512;delay++);
  63:usb.c         **** 
  64:usb.c         ****     //  volatile unsigned x = 1024; do { ; }while(--x);// wait a moment
  65:usb.c         ****     /* turn on the USB clock */
  66:usb.c         ****     SET_REG(GPIO_CR(USB_DISC_BANK,USB_DISC_PIN),
  67:usb.c         ****         (GET_REG(GPIO_CR(USB_DISC_BANK,USB_DISC_PIN)) & crMask(USB_DISC_PIN)) | CR_INPUT << CR_SHIT
  68:usb.c         ****     //  pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
  69:usb.c         **** #endif
  70:usb.c         ****     /* initialize the usb application */
  71:usb.c         **** 
  72:usb.c         ****     wTransferSize=getFlashPageSize();
  73:usb.c         ****     u8_usbConfigDescriptorDFU[41]=(wTransferSize & 0x00FF);
  74:usb.c         ****     u8_usbConfigDescriptorDFU[42]=(wTransferSize & 0xFF00)>>8;
  75:usb.c         **** 
  76:usb.c         ****     u8_usbFunctionalDescriptor[5]=(wTransferSize & 0x00FF);
  77:usb.c         ****     u8_usbFunctionalDescriptor[6]=(wTransferSize & 0xFF00)>>8;
  78:usb.c         **** 
  79:usb.c         ****     usbAppInit();
  80:usb.c         **** 
  81:usb.c         **** }
  82:usb.c         **** 
  83:usb.c         **** 
  84:usb.c         **** 
  85:usb.c         **** 
  86:usb.c         **** void usbDsbBus(void) {
  87:usb.c         **** // setPin(USB_DISC_BANK,USB_DISC_PIN);
  88:usb.c         **** usbPowerOff();
  89:usb.c         **** // SET_REG(USB_DISC_CR,
  90:usb.c         **** // (GET_REG(USB_DISC_CR) & USB_DISC_CR_MASK) | USB_DISC_CR_OUTPUT);
  91:usb.c         **** // resetPin(USB_DISC_BANK, USB_DISC_PIN); /* Pull DP+ down */
  92:usb.c         **** // volatile unsigned x = 500000; do { ; }while(--x);
  93:usb.c         **** // SET_REG(USB_DISC_CR,
  94:usb.c         **** // (GET_REG(USB_DISC_CR) & USB_DISC_CR_MASK) | USB_DISC_CR_INPUT); //Sets the PA12 as floating inpu
  95:usb.c         **** }
  96:usb.c         **** 
  97:usb.c         **** vu32 bDeviceState = UNCONNECTED;
  98:usb.c         **** 
  99:usb.c         **** /* tracks sequential behavior of the ISTR */
 100:usb.c         **** vu16 wIstr;
 101:usb.c         **** vu8 bIntPackSOF = 0;
 102:usb.c         **** 
 103:usb.c         **** DEVICE Device_Table = {
 104:usb.c         ****     NUM_ENDPTS,
 105:usb.c         ****     1
 106:usb.c         **** };
 107:usb.c         **** 
 108:usb.c         **** DEVICE_PROP Device_Property = {
 109:usb.c         ****     usbInit,
 110:usb.c         ****     usbReset,
 111:usb.c         ****     usbStatusIn,
 112:usb.c         ****     usbStatusOut,
 113:usb.c         ****     usbDataSetup,
 114:usb.c         ****     usbNoDataSetup,
 115:usb.c         ****     usbGetInterfaceSetting,
 116:usb.c         ****     usbGetDeviceDescriptor,
 117:usb.c         ****     usbGetConfigDescriptor,
 118:usb.c         ****     usbGetStringDescriptor,
 119:usb.c         ****     usbGetFunctionalDescriptor,
 120:usb.c         ****     0,
 121:usb.c         ****     bMaxPacketSize
 122:usb.c         **** };
 123:usb.c         **** 
 124:usb.c         **** USER_STANDARD_REQUESTS User_Standard_Requests = {
 125:usb.c         ****     usbGetConfiguration,
 126:usb.c         ****     usbSetConfiguration,
 127:usb.c         ****     usbGetInterface,
 128:usb.c         ****     usbSetInterface,
 129:usb.c         ****     usbGetStatus,
 130:usb.c         ****     usbClearFeature,
 131:usb.c         ****     usbSetEndpointFeature,
 132:usb.c         ****     usbSetDeviceFeature,
 133:usb.c         ****     usbSetDeviceAddress
 134:usb.c         **** };
 135:usb.c         **** 
 136:usb.c         **** void (*pEpInt_IN[7])(void) = {
 137:usb.c         ****     nothingProc,
 138:usb.c         ****     nothingProc,
 139:usb.c         ****     nothingProc,
 140:usb.c         ****     nothingProc,
 141:usb.c         ****     nothingProc,
 142:usb.c         ****     nothingProc,
 143:usb.c         ****     nothingProc,
 144:usb.c         **** };
 145:usb.c         **** 
 146:usb.c         **** void (*pEpInt_OUT[7])(void) = {
 147:usb.c         ****     nothingProc,
 148:usb.c         ****     nothingProc,
 149:usb.c         ****     nothingProc,
 150:usb.c         ****     nothingProc,
 151:usb.c         ****     nothingProc,
 152:usb.c         ****     nothingProc,
 153:usb.c         ****     nothingProc,
 154:usb.c         **** };
 155:usb.c         **** 
 156:usb.c         **** struct {
 157:usb.c         ****     volatile RESUME_STATE eState;
 158:usb.c         ****     volatile u8 bESOFcnt;
 159:usb.c         **** } ResumeS;
 160:usb.c         **** 
 161:usb.c         **** /* dummy proc */
 162:usb.c         **** void nothingProc(void) {
 163:usb.c         **** }
 164:usb.c         **** 
 165:usb.c         **** /* Function Definitions */
 166:usb.c         **** void usbAppInit(void) {
 167:usb.c         ****     /* hook in to usb_core, depends on all those damn
 168:usb.c         ****        non encapsulated externs! */
 169:usb.c         ****     USB_Init();
 170:usb.c         **** }
 171:usb.c         **** 
 172:usb.c         **** void usbSuspend(void) {
 173:usb.c         ****     u16 wCNTR;
 174:usb.c         ****     wCNTR = _GetCNTR();
 175:usb.c         ****     wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
 176:usb.c         ****     _SetCNTR(wCNTR);
 177:usb.c         **** 
 178:usb.c         ****     /* run any power reduction handlers */
 179:usb.c         ****     bDeviceState = SUSPENDED;
 180:usb.c         **** }
 181:usb.c         **** 
 182:usb.c         **** void usbResumeInit(void) {
 183:usb.c         ****     u16 wCNTR;
 184:usb.c         **** 
 185:usb.c         ****     /* restart any clocks that had been stopped */
 186:usb.c         **** 
 187:usb.c         ****     wCNTR = _GetCNTR();
 188:usb.c         ****     wCNTR &= (~CNTR_LPMODE);
 189:usb.c         ****     _SetCNTR(wCNTR);
 190:usb.c         **** 
 191:usb.c         ****     /* undo power reduction handlers here */
 192:usb.c         **** 
 193:usb.c         ****     _SetCNTR(ISR_MSK);
 194:usb.c         **** }
 195:usb.c         **** 
 196:usb.c         **** void usbResume(RESUME_STATE eResumeSetVal) {
 197:usb.c         ****     u16 wCNTR;
 198:usb.c         **** 
 199:usb.c         ****     if (eResumeSetVal != RESUME_ESOF)
 200:usb.c         ****         ResumeS.eState = eResumeSetVal;
 201:usb.c         **** 
 202:usb.c         ****     switch (ResumeS.eState) {
 203:usb.c         ****     case RESUME_EXTERNAL:
 204:usb.c         ****         usbResumeInit();
 205:usb.c         ****         ResumeS.eState = RESUME_OFF;
 206:usb.c         ****         break;
 207:usb.c         ****     case RESUME_INTERNAL:
 208:usb.c         ****         usbResumeInit();
 209:usb.c         ****         ResumeS.eState = RESUME_START;
 210:usb.c         ****         break;
 211:usb.c         ****     case RESUME_LATER:
 212:usb.c         ****         ResumeS.bESOFcnt = 2;
 213:usb.c         ****         ResumeS.eState = RESUME_WAIT;
 214:usb.c         ****         break;
 215:usb.c         ****     case RESUME_WAIT:
 216:usb.c         ****         ResumeS.bESOFcnt--;
 217:usb.c         ****         if (ResumeS.bESOFcnt == 0)
 218:usb.c         ****             ResumeS.eState = RESUME_START;
 219:usb.c         ****         break;
 220:usb.c         ****     case RESUME_START:
 221:usb.c         ****         wCNTR = _GetCNTR();
 222:usb.c         ****         wCNTR |= CNTR_RESUME;
 223:usb.c         ****         _SetCNTR(wCNTR);
 224:usb.c         ****         ResumeS.eState = RESUME_ON;
 225:usb.c         ****         ResumeS.bESOFcnt = 10;
 226:usb.c         ****         break;
 227:usb.c         ****     case RESUME_ON:
 228:usb.c         ****         ResumeS.bESOFcnt--;
 229:usb.c         ****         if (ResumeS.bESOFcnt == 0) {
 230:usb.c         ****             wCNTR = _GetCNTR();
 231:usb.c         ****             wCNTR &= (~CNTR_RESUME);
 232:usb.c         ****             _SetCNTR(wCNTR);
 233:usb.c         ****             ResumeS.eState = RESUME_OFF;
 234:usb.c         ****         }
 235:usb.c         ****         break;
 236:usb.c         ****     case RESUME_OFF:
 237:usb.c         ****     case RESUME_ESOF:
 238:usb.c         ****     default:
 239:usb.c         ****         ResumeS.eState = RESUME_OFF;
 240:usb.c         ****         break;
 241:usb.c         ****     }
 242:usb.c         **** }
 243:usb.c         **** 
 244:usb.c         **** RESULT usbPowerOn(void) {
 245:usb.c         ****     u16 wRegVal;
 246:usb.c         **** 
 247:usb.c         ****     wRegVal = CNTR_FRES;
 248:usb.c         ****     _SetCNTR(wRegVal);
 249:usb.c         **** 
 250:usb.c         ****     wInterrupt_Mask = 0;
 251:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 252:usb.c         ****     _SetISTR(0);
 253:usb.c         ****     wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
 254:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 255:usb.c         **** 
 256:usb.c         ****     return USB_SUCCESS;
 257:usb.c         **** }
 258:usb.c         **** 
 259:usb.c         **** RESULT usbPowerOff(void) {
 260:usb.c         ****     _SetCNTR(CNTR_FRES);
 261:usb.c         ****     _SetISTR(0);
 262:usb.c         ****     _SetCNTR(CNTR_FRES + CNTR_PDWN);
 263:usb.c         **** 
 264:usb.c         ****     /* note that all weve done here is powerdown the
 265:usb.c         ****        usb peripheral. we have no disabled the clocks,
 266:usb.c         ****        pulled the USB_DISC_PIN pin back up, or reset the
 267:usb.c         ****        application state machines */
 268:usb.c         **** 
 269:usb.c         ****     return USB_SUCCESS;
 270:usb.c         **** }
 271:usb.c         **** 
 272:usb.c         **** void usbInit(void) {
 273:usb.c         ****     dfuInit();
 274:usb.c         **** 
 275:usb.c         ****     pInformation->Current_Configuration = 0;
 276:usb.c         ****     usbPowerOn();
 277:usb.c         **** 
 278:usb.c         ****     _SetISTR(0);
 279:usb.c         ****     wInterrupt_Mask = ISR_MSK;
 280:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 281:usb.c         **** 
 282:usb.c         ****     usbEnbISR(); /* configure the cortex M3 private peripheral NVIC */
 283:usb.c         ****     bDeviceState = UNCONNECTED;
 284:usb.c         **** }
 285:usb.c         **** 
 286:usb.c         **** void usbReset(void) {
 287:usb.c         ****     dfuUpdateByReset();
 288:usb.c         **** 
 289:usb.c         ****     pInformation->Current_Configuration = 0;
 290:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 291:usb.c         **** 
 292:usb.c         ****     _SetBTABLE(BTABLE_ADDRESS);
 293:usb.c         **** 
 294:usb.c         ****     /* setup the ctrl endpoint */
 295:usb.c         ****     _SetEPType(ENDP0, EP_CONTROL);
 296:usb.c         ****     _SetEPTxStatus(ENDP0, EP_TX_STALL);
 297:usb.c         **** 
 298:usb.c         ****     _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
 299:usb.c         ****     _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
 300:usb.c         **** 
 301:usb.c         ****     Clear_Status_Out(ENDP0);
 302:usb.c         **** 
 303:usb.c         ****     SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 304:usb.c         ****     //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
 305:usb.c         ****     SetEPRxValid(ENDP0);
 306:usb.c         **** 
 307:usb.c         ****     bDeviceState = ATTACHED;
 308:usb.c         ****     SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
 309:usb.c         **** }
 310:usb.c         **** 
 311:usb.c         **** void usbStatusIn(void) {
  27              		.loc 1 311 24 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
 312:usb.c         **** }
  32              		.loc 1 312 1 view .LVU1
  33 0000 7047     		bx	lr
  34              		.cfi_endproc
  35              	.LFE11:
  37              		.section	.text.usbGetInterfaceSetting,"ax",%progbits
  38              		.align	1
  39              		.global	usbGetInterfaceSetting
  40              		.syntax unified
  41              		.thumb
  42              		.thumb_func
  43              		.fpu softvfp
  45              	usbGetInterfaceSetting:
  46              	.LVL0:
  47              	.LFB15:
 313:usb.c         **** 
 314:usb.c         **** void usbStatusOut(void) {
 315:usb.c         **** }
 316:usb.c         **** 
 317:usb.c         **** RESULT usbDataSetup(u8 request) {
 318:usb.c         ****     u8 *(*CopyRoutine)(u16);
 319:usb.c         ****     CopyRoutine = NULL;
 320:usb.c         **** 
 321:usb.c         ****     /* handle dfu class requests */
 322:usb.c         ****     if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE
 323:usb.c         ****         if (dfuUpdateByRequest()) {
 324:usb.c         ****             /* successfull state transition, handle the request */
 325:usb.c         ****             switch (request) {
 326:usb.c         ****             case(DFU_GETSTATUS):
 327:usb.c         ****                 CopyRoutine = dfuCopyStatus;
 328:usb.c         ****                 break;
 329:usb.c         ****             case(DFU_GETSTATE):
 330:usb.c         ****                 CopyRoutine = dfuCopyState;
 331:usb.c         ****                 break;
 332:usb.c         ****             case(DFU_DNLOAD):
 333:usb.c         ****                 CopyRoutine = dfuCopyDNLOAD;
 334:usb.c         ****                 break;
 335:usb.c         ****             case(DFU_UPLOAD):
 336:usb.c         ****                 CopyRoutine = dfuCopyUPLOAD;
 337:usb.c         ****                 break;
 338:usb.c         ****             default:
 339:usb.c         ****                 /* leave copy routine null */
 340:usb.c         ****                 break;
 341:usb.c         ****             }
 342:usb.c         ****         }
 343:usb.c         ****     }
 344:usb.c         **** 
 345:usb.c         ****     if (CopyRoutine != NULL) {
 346:usb.c         ****         pInformation->Ctrl_Info.CopyData = CopyRoutine;
 347:usb.c         ****         pInformation->Ctrl_Info.Usb_wOffset = 0;
 348:usb.c         ****         (*CopyRoutine)(0);
 349:usb.c         **** 
 350:usb.c         ****         return USB_SUCCESS;
 351:usb.c         ****     }
 352:usb.c         **** 
 353:usb.c         ****     return USB_UNSUPPORT;
 354:usb.c         **** }
 355:usb.c         **** 
 356:usb.c         **** RESULT usbNoDataSetup(u8 request) {
 357:usb.c         ****     if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE
 358:usb.c         ****         /* todo, keep track of the destination interface, often stored in wIndex */
 359:usb.c         ****         if (dfuUpdateByRequest()) {
 360:usb.c         ****             return USB_SUCCESS;
 361:usb.c         ****         }
 362:usb.c         ****     }
 363:usb.c         ****     return USB_UNSUPPORT;
 364:usb.c         **** }
 365:usb.c         **** 
 366:usb.c         **** RESULT usbGetInterfaceSetting(u8 interface, u8 altSetting) {
  48              		.loc 1 366 60 view -0
  49              		.cfi_startproc
  50              		@ args = 0, pretend = 0, frame = 0
  51              		@ frame_needed = 0, uses_anonymous_args = 0
  52              		@ link register save eliminated.
 367:usb.c         ****     /* alt setting 0 -> program RAM, alt setting 1 -> FLASH */
 368:usb.c         ****     if (interface > NUM_ALT_SETTINGS) {
  53              		.loc 1 368 5 view .LVU3
 369:usb.c         ****         return USB_UNSUPPORT;
 370:usb.c         ****     } else {
 371:usb.c         ****         return USB_SUCCESS;
  54              		.loc 1 371 16 is_stmt 0 view .LVU4
  55 0000 0328     		cmp	r0, #3
 372:usb.c         ****     }
 373:usb.c         **** }
  56              		.loc 1 373 1 view .LVU5
  57 0002 8CBF     		ite	hi
  58 0004 0220     		movhi	r0, #2
  59              	.LVL1:
  60              		.loc 1 373 1 view .LVU6
  61 0006 0020     		movls	r0, #0
  62 0008 7047     		bx	lr
  63              		.cfi_endproc
  64              	.LFE15:
  66              		.section	.text.usbSetConfiguration,"ax",%progbits
  67              		.align	1
  68              		.global	usbSetConfiguration
  69              		.syntax unified
  70              		.thumb
  71              		.thumb_func
  72              		.fpu softvfp
  74              	usbSetConfiguration:
  75              	.LFB21:
 374:usb.c         **** 
 375:usb.c         **** u8 *usbGetDeviceDescriptor(u16 len) {
 376:usb.c         ****     return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
 377:usb.c         **** }
 378:usb.c         **** 
 379:usb.c         **** u8 *usbGetConfigDescriptor(u16 len) {
 380:usb.c         ****     return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
 381:usb.c         **** }
 382:usb.c         **** 
 383:usb.c         **** u8 *usbGetStringDescriptor(u16 len) {
 384:usb.c         ****     u8 strIndex = pInformation->USBwValue0;
 385:usb.c         ****     if (strIndex > STR_DESC_LEN) {
 386:usb.c         ****         return NULL;
 387:usb.c         ****     } else {
 388:usb.c         ****         return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
 389:usb.c         ****     }
 390:usb.c         **** }
 391:usb.c         **** 
 392:usb.c         **** u8 *usbGetFunctionalDescriptor(u16 len) {
 393:usb.c         ****     return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
 394:usb.c         **** }
 395:usb.c         **** 
 396:usb.c         **** 
 397:usb.c         **** 
 398:usb.c         **** /***** start of USER STANDARD REQUESTS ******
 399:usb.c         ****  *
 400:usb.c         ****  * These are the USER STANDARD REQUESTS, they are handled
 401:usb.c         ****  * in the core but we are given these callbacks at the
 402:usb.c         ****  * application level
 403:usb.c         ****  *******************************************/
 404:usb.c         **** 
 405:usb.c         **** void usbGetConfiguration(void) {
 406:usb.c         ****     /* nothing process */
 407:usb.c         **** }
 408:usb.c         **** 
 409:usb.c         **** void usbSetConfiguration(void) {
  76              		.loc 1 409 32 is_stmt 1 view -0
  77              		.cfi_startproc
  78              		@ args = 0, pretend = 0, frame = 0
  79              		@ frame_needed = 0, uses_anonymous_args = 0
  80              		@ link register save eliminated.
 410:usb.c         ****     if (pInformation->Current_Configuration != 0) {
  81              		.loc 1 410 5 view .LVU8
  82              		.loc 1 410 21 is_stmt 0 view .LVU9
  83 0000 034B     		ldr	r3, .L10
  84 0002 1B68     		ldr	r3, [r3]
  85              		.loc 1 410 8 view .LVU10
  86 0004 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
  87 0006 13B1     		cbz	r3, .L5
 411:usb.c         ****         bDeviceState = CONFIGURED;
  88              		.loc 1 411 9 is_stmt 1 view .LVU11
  89              		.loc 1 411 22 is_stmt 0 view .LVU12
  90 0008 0522     		movs	r2, #5
  91 000a 024B     		ldr	r3, .L10+4
  92 000c 1A60     		str	r2, [r3]
  93              	.L5:
 412:usb.c         ****     }
 413:usb.c         **** }
  94              		.loc 1 413 1 view .LVU13
  95 000e 7047     		bx	lr
  96              	.L11:
  97              		.align	2
  98              	.L10:
  99 0010 00000000 		.word	pInformation
 100 0014 00000000 		.word	.LANCHOR0
 101              		.cfi_endproc
 102              	.LFE21:
 104              		.section	.text.usbSetDeviceAddress,"ax",%progbits
 105              		.align	1
 106              		.global	usbSetDeviceAddress
 107              		.syntax unified
 108              		.thumb
 109              		.thumb_func
 110              		.fpu softvfp
 112              	usbSetDeviceAddress:
 113              	.LFB28:
 414:usb.c         **** 
 415:usb.c         **** void usbGetInterface(void) {
 416:usb.c         ****     /* nothing process */
 417:usb.c         **** }
 418:usb.c         **** 
 419:usb.c         **** void usbSetInterface(void) {
 420:usb.c         ****     /* nothing process */
 421:usb.c         **** }
 422:usb.c         **** 
 423:usb.c         **** void usbGetStatus(void) {
 424:usb.c         ****     /* nothing process */
 425:usb.c         **** }
 426:usb.c         **** 
 427:usb.c         **** void usbClearFeature(void) {
 428:usb.c         ****     /* nothing process */
 429:usb.c         **** }
 430:usb.c         **** 
 431:usb.c         **** void usbSetEndpointFeature(void) {
 432:usb.c         ****     /* nothing process */
 433:usb.c         **** }
 434:usb.c         **** 
 435:usb.c         **** void usbSetDeviceFeature(void) {
 436:usb.c         ****     /* nothing process */
 437:usb.c         **** }
 438:usb.c         **** 
 439:usb.c         **** void usbSetDeviceAddress(void) {
 114              		.loc 1 439 32 is_stmt 1 view -0
 115              		.cfi_startproc
 116              		@ args = 0, pretend = 0, frame = 0
 117              		@ frame_needed = 0, uses_anonymous_args = 0
 118              		@ link register save eliminated.
 440:usb.c         ****     bDeviceState = ADDRESSED;
 119              		.loc 1 440 5 view .LVU15
 120              		.loc 1 440 18 is_stmt 0 view .LVU16
 121 0000 0422     		movs	r2, #4
 122 0002 014B     		ldr	r3, .L13
 123 0004 1A60     		str	r2, [r3]
 441:usb.c         **** }
 124              		.loc 1 441 1 view .LVU17
 125 0006 7047     		bx	lr
 126              	.L14:
 127              		.align	2
 128              	.L13:
 129 0008 00000000 		.word	.LANCHOR0
 130              		.cfi_endproc
 131              	.LFE28:
 133              		.section	.text.usbReset,"ax",%progbits
 134              		.align	1
 135              		.global	usbReset
 136              		.syntax unified
 137              		.thumb
 138              		.thumb_func
 139              		.fpu softvfp
 141              	usbReset:
 142              	.LFB10:
 286:usb.c         ****     dfuUpdateByReset();
 143              		.loc 1 286 21 is_stmt 1 view -0
 144              		.cfi_startproc
 145              		@ args = 0, pretend = 0, frame = 0
 146              		@ frame_needed = 0, uses_anonymous_args = 0
 287:usb.c         **** 
 147              		.loc 1 287 5 view .LVU19
 286:usb.c         ****     dfuUpdateByReset();
 148              		.loc 1 286 21 is_stmt 0 view .LVU20
 149 0000 10B5     		push	{r4, lr}
 150              		.cfi_def_cfa_offset 8
 151              		.cfi_offset 4, -8
 152              		.cfi_offset 14, -4
 289:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 153              		.loc 1 289 41 view .LVU21
 154 0002 0024     		movs	r4, #0
 287:usb.c         **** 
 155              		.loc 1 287 5 view .LVU22
 156 0004 FFF7FEFF 		bl	dfuUpdateByReset
 157              	.LVL2:
 289:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 158              		.loc 1 289 5 is_stmt 1 view .LVU23
 289:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 159              		.loc 1 289 17 is_stmt 0 view .LVU24
 160 0008 234B     		ldr	r3, .L16
 290:usb.c         **** 
 161              		.loc 1 290 59 view .LVU25
 162 000a 244A     		ldr	r2, .L16+4
 289:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 163              		.loc 1 289 17 view .LVU26
 164 000c 1B68     		ldr	r3, [r3]
 290:usb.c         **** 
 165              		.loc 1 290 35 view .LVU27
 166 000e 1268     		ldr	r2, [r2]
 289:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 167              		.loc 1 289 41 view .LVU28
 168 0010 9C72     		strb	r4, [r3, #10]
 290:usb.c         **** 
 169              		.loc 1 290 5 is_stmt 1 view .LVU29
 290:usb.c         **** 
 170              		.loc 1 290 35 is_stmt 0 view .LVU30
 171 0012 D279     		ldrb	r2, [r2, #7]	@ zero_extendqisi2
 301:usb.c         **** 
 172              		.loc 1 301 5 view .LVU31
 173 0014 2046     		mov	r0, r4
 290:usb.c         **** 
 174              		.loc 1 290 35 view .LVU32
 175 0016 5A72     		strb	r2, [r3, #9]
 292:usb.c         **** 
 176              		.loc 1 292 5 is_stmt 1 view .LVU33
 177 0018 214A     		ldr	r2, .L16+8
 178 001a C2F8504C 		str	r4, [r2, #3152]
 295:usb.c         ****     _SetEPTxStatus(ENDP0, EP_TX_STALL);
 179              		.loc 1 295 5 view .LVU34
 180 001e D2F8003C 		ldr	r3, [r2, #3072]
 181 0022 23F4EC43 		bic	r3, r3, #30208
 182 0026 23F07003 		bic	r3, r3, #112
 183 002a 43F40073 		orr	r3, r3, #512
 184 002e 9BB2     		uxth	r3, r3
 185 0030 C2F8003C 		str	r3, [r2, #3072]
 186              	.LBB4:
 296:usb.c         **** 
 187              		.loc 1 296 5 view .LVU35
 296:usb.c         **** 
 188              		.loc 1 296 5 view .LVU36
 189 0034 D2F8003C 		ldr	r3, [r2, #3072]
 190 0038 23F4E043 		bic	r3, r3, #28672
 191 003c 23F04003 		bic	r3, r3, #64
 192 0040 9BB2     		uxth	r3, r3
 193              	.LVL3:
 296:usb.c         **** 
 194              		.loc 1 296 5 view .LVU37
 296:usb.c         **** 
 195              		.loc 1 296 5 view .LVU38
 296:usb.c         **** 
 196              		.loc 1 296 5 view .LVU39
 296:usb.c         **** 
 197              		.loc 1 296 5 view .LVU40
 198 0042 83F01003 		eor	r3, r3, #16
 199              	.LVL4:
 296:usb.c         **** 
 200              		.loc 1 296 5 is_stmt 0 view .LVU41
 201 0046 C2F8003C 		str	r3, [r2, #3072]
 202              	.LBE4:
 296:usb.c         **** 
 203              		.loc 1 296 39 is_stmt 1 view .LVU42
 298:usb.c         ****     _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
 204              		.loc 1 298 5 view .LVU43
 205 004a D2F8501C 		ldr	r1, [r2, #3152]
 206 004e 154B     		ldr	r3, .L16+12
 207              	.LVL5:
 298:usb.c         ****     _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
 208              		.loc 1 298 5 is_stmt 0 view .LVU44
 209 0050 89B2     		uxth	r1, r1
 210 0052 0B44     		add	r3, r3, r1
 211 0054 4021     		movs	r1, #64
 212 0056 5B00     		lsls	r3, r3, #1
 213 0058 1960     		str	r1, [r3]
 214              	.LVL6:
 299:usb.c         **** 
 215              		.loc 1 299 5 is_stmt 1 view .LVU45
 216 005a D2F8503C 		ldr	r3, [r2, #3152]
 217 005e 8022     		movs	r2, #128
 218 0060 9BB2     		uxth	r3, r3
 219 0062 03F10053 		add	r3, r3, #536870912
 220 0066 03F54053 		add	r3, r3, #12288
 221 006a 5B00     		lsls	r3, r3, #1
 222 006c 1A60     		str	r2, [r3]
 301:usb.c         **** 
 223              		.loc 1 301 5 view .LVU46
 224 006e FFF7FEFF 		bl	Clear_Status_Out
 225              	.LVL7:
 303:usb.c         ****     //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
 226              		.loc 1 303 5 view .LVU47
 303:usb.c         ****     //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
 227              		.loc 1 303 34 is_stmt 0 view .LVU48
 228 0072 0D4B     		ldr	r3, .L16+16
 303:usb.c         ****     //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
 229              		.loc 1 303 5 view .LVU49
 230 0074 2046     		mov	r0, r4
 303:usb.c         ****     //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
 231              		.loc 1 303 34 view .LVU50
 232 0076 1B68     		ldr	r3, [r3]
 303:usb.c         ****     //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
 233              		.loc 1 303 5 view .LVU51
 234 0078 93F83010 		ldrb	r1, [r3, #48]	@ zero_extendqisi2
 235 007c FFF7FEFF 		bl	SetEPRxCount
 236              	.LVL8:
 305:usb.c         **** 
 237              		.loc 1 305 5 is_stmt 1 view .LVU52
 238 0080 2046     		mov	r0, r4
 239 0082 FFF7FEFF 		bl	SetEPRxValid
 240              	.LVL9:
 307:usb.c         ****     SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
 241              		.loc 1 307 5 view .LVU53
 307:usb.c         ****     SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
 242              		.loc 1 307 18 is_stmt 0 view .LVU54
 243 0086 0122     		movs	r2, #1
 244 0088 084B     		ldr	r3, .L16+20
 308:usb.c         **** }
 245              		.loc 1 308 5 view .LVU55
 246 008a 2046     		mov	r0, r4
 309:usb.c         **** 
 247              		.loc 1 309 1 view .LVU56
 248 008c BDE81040 		pop	{r4, lr}
 249              		.cfi_restore 14
 250              		.cfi_restore 4
 251              		.cfi_def_cfa_offset 0
 307:usb.c         ****     SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
 252              		.loc 1 307 18 view .LVU57
 253 0090 1A60     		str	r2, [r3]
 308:usb.c         **** }
 254              		.loc 1 308 5 is_stmt 1 view .LVU58
 255 0092 FFF7FEBF 		b	SetDeviceAddress
 256              	.LVL10:
 257              	.L17:
 258 0096 00BF     		.align	2
 259              	.L16:
 260 0098 00000000 		.word	pInformation
 261 009c 00000000 		.word	usbConfigDescriptorDFU
 262 00a0 00500040 		.word	1073762304
 263 00a4 04300020 		.word	536883204
 264 00a8 00000000 		.word	pProperty
 265 00ac 00000000 		.word	.LANCHOR0
 266              		.cfi_endproc
 267              	.LFE10:
 269              		.section	.text.usbGetDeviceDescriptor,"ax",%progbits
 270              		.align	1
 271              		.global	usbGetDeviceDescriptor
 272              		.syntax unified
 273              		.thumb
 274              		.thumb_func
 275              		.fpu softvfp
 277              	usbGetDeviceDescriptor:
 278              	.LVL11:
 279              	.LFB16:
 375:usb.c         ****     return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
 280              		.loc 1 375 37 view -0
 281              		.cfi_startproc
 282              		@ args = 0, pretend = 0, frame = 0
 283              		@ frame_needed = 0, uses_anonymous_args = 0
 284              		@ link register save eliminated.
 376:usb.c         **** }
 285              		.loc 1 376 5 view .LVU60
 376:usb.c         **** }
 286              		.loc 1 376 12 is_stmt 0 view .LVU61
 287 0000 0149     		ldr	r1, .L19
 288 0002 FFF7FEBF 		b	Standard_GetDescriptorData
 289              	.LVL12:
 290              	.L20:
 376:usb.c         **** }
 291              		.loc 1 376 12 view .LVU62
 292 0006 00BF     		.align	2
 293              	.L19:
 294 0008 00000000 		.word	usbDeviceDescriptorDFU
 295              		.cfi_endproc
 296              	.LFE16:
 298              		.section	.text.usbGetConfigDescriptor,"ax",%progbits
 299              		.align	1
 300              		.global	usbGetConfigDescriptor
 301              		.syntax unified
 302              		.thumb
 303              		.thumb_func
 304              		.fpu softvfp
 306              	usbGetConfigDescriptor:
 307              	.LVL13:
 308              	.LFB17:
 379:usb.c         ****     return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
 309              		.loc 1 379 37 is_stmt 1 view -0
 310              		.cfi_startproc
 311              		@ args = 0, pretend = 0, frame = 0
 312              		@ frame_needed = 0, uses_anonymous_args = 0
 313              		@ link register save eliminated.
 380:usb.c         **** }
 314              		.loc 1 380 5 view .LVU64
 380:usb.c         **** }
 315              		.loc 1 380 12 is_stmt 0 view .LVU65
 316 0000 0149     		ldr	r1, .L22
 317 0002 FFF7FEBF 		b	Standard_GetDescriptorData
 318              	.LVL14:
 319              	.L23:
 380:usb.c         **** }
 320              		.loc 1 380 12 view .LVU66
 321 0006 00BF     		.align	2
 322              	.L22:
 323 0008 00000000 		.word	usbConfigDescriptorDFU
 324              		.cfi_endproc
 325              	.LFE17:
 327              		.section	.text.usbGetStringDescriptor,"ax",%progbits
 328              		.align	1
 329              		.global	usbGetStringDescriptor
 330              		.syntax unified
 331              		.thumb
 332              		.thumb_func
 333              		.fpu softvfp
 335              	usbGetStringDescriptor:
 336              	.LVL15:
 337              	.LFB18:
 383:usb.c         ****     u8 strIndex = pInformation->USBwValue0;
 338              		.loc 1 383 37 is_stmt 1 view -0
 339              		.cfi_startproc
 340              		@ args = 0, pretend = 0, frame = 0
 341              		@ frame_needed = 0, uses_anonymous_args = 0
 342              		@ link register save eliminated.
 384:usb.c         ****     if (strIndex > STR_DESC_LEN) {
 343              		.loc 1 384 5 view .LVU68
 384:usb.c         ****     if (strIndex > STR_DESC_LEN) {
 344              		.loc 1 384 8 is_stmt 0 view .LVU69
 345 0000 054B     		ldr	r3, .L26
 346 0002 1B68     		ldr	r3, [r3]
 347 0004 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 348              	.LVL16:
 385:usb.c         ****         return NULL;
 349              		.loc 1 385 5 is_stmt 1 view .LVU70
 385:usb.c         ****         return NULL;
 350              		.loc 1 385 8 is_stmt 0 view .LVU71
 351 0006 072B     		cmp	r3, #7
 352 0008 04D8     		bhi	.L25
 388:usb.c         ****     }
 353              		.loc 1 388 9 is_stmt 1 view .LVU72
 388:usb.c         ****     }
 354              		.loc 1 388 16 is_stmt 0 view .LVU73
 355 000a 0449     		ldr	r1, .L26+4
 356 000c 01EBC301 		add	r1, r1, r3, lsl #3
 357 0010 FFF7FEBF 		b	Standard_GetDescriptorData
 358              	.LVL17:
 359              	.L25:
 390:usb.c         **** 
 360              		.loc 1 390 1 view .LVU74
 361 0014 0020     		movs	r0, #0
 362              	.LVL18:
 390:usb.c         **** 
 363              		.loc 1 390 1 view .LVU75
 364 0016 7047     		bx	lr
 365              	.L27:
 366              		.align	2
 367              	.L26:
 368 0018 00000000 		.word	pInformation
 369 001c 00000000 		.word	usbStringDescriptor
 370              		.cfi_endproc
 371              	.LFE18:
 373              		.section	.text.usbGetFunctionalDescriptor,"ax",%progbits
 374              		.align	1
 375              		.global	usbGetFunctionalDescriptor
 376              		.syntax unified
 377              		.thumb
 378              		.thumb_func
 379              		.fpu softvfp
 381              	usbGetFunctionalDescriptor:
 382              	.LVL19:
 383              	.LFB19:
 392:usb.c         ****     return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
 384              		.loc 1 392 41 is_stmt 1 view -0
 385              		.cfi_startproc
 386              		@ args = 0, pretend = 0, frame = 0
 387              		@ frame_needed = 0, uses_anonymous_args = 0
 388              		@ link register save eliminated.
 393:usb.c         **** }
 389              		.loc 1 393 5 view .LVU77
 393:usb.c         **** }
 390              		.loc 1 393 12 is_stmt 0 view .LVU78
 391 0000 0149     		ldr	r1, .L29
 392 0002 FFF7FEBF 		b	Standard_GetDescriptorData
 393              	.LVL20:
 394              	.L30:
 393:usb.c         **** }
 395              		.loc 1 393 12 view .LVU79
 396 0006 00BF     		.align	2
 397              	.L29:
 398 0008 00000000 		.word	usbFunctionalDescriptor
 399              		.cfi_endproc
 400              	.LFE19:
 402              		.section	.text.usbDataSetup,"ax",%progbits
 403              		.align	1
 404              		.global	usbDataSetup
 405              		.syntax unified
 406              		.thumb
 407              		.thumb_func
 408              		.fpu softvfp
 410              	usbDataSetup:
 411              	.LVL21:
 412              	.LFB13:
 317:usb.c         ****     u8 *(*CopyRoutine)(u16);
 413              		.loc 1 317 33 is_stmt 1 view -0
 414              		.cfi_startproc
 415              		@ args = 0, pretend = 0, frame = 0
 416              		@ frame_needed = 0, uses_anonymous_args = 0
 318:usb.c         ****     CopyRoutine = NULL;
 417              		.loc 1 318 5 view .LVU81
 319:usb.c         **** 
 418              		.loc 1 319 5 view .LVU82
 322:usb.c         ****         if (dfuUpdateByRequest()) {
 419              		.loc 1 322 5 view .LVU83
 317:usb.c         ****     u8 *(*CopyRoutine)(u16);
 420              		.loc 1 317 33 is_stmt 0 view .LVU84
 421 0000 38B5     		push	{r3, r4, r5, lr}
 422              		.cfi_def_cfa_offset 16
 423              		.cfi_offset 3, -16
 424              		.cfi_offset 4, -12
 425              		.cfi_offset 5, -8
 426              		.cfi_offset 14, -4
 322:usb.c         ****         if (dfuUpdateByRequest()) {
 427              		.loc 1 322 22 view .LVU85
 428 0002 174D     		ldr	r5, .L45
 317:usb.c         ****     u8 *(*CopyRoutine)(u16);
 429              		.loc 1 317 33 view .LVU86
 430 0004 0446     		mov	r4, r0
 322:usb.c         ****         if (dfuUpdateByRequest()) {
 431              		.loc 1 322 22 view .LVU87
 432 0006 2B68     		ldr	r3, [r5]
 322:usb.c         ****         if (dfuUpdateByRequest()) {
 433              		.loc 1 322 8 view .LVU88
 434 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 435 000a 03F07F03 		and	r3, r3, #127
 436 000e 212B     		cmp	r3, #33
 437 0010 01D0     		beq	.L32
 438              	.LVL22:
 439              	.L40:
 323:usb.c         ****             /* successfull state transition, handle the request */
 440              		.loc 1 323 12 view .LVU89
 441 0012 0220     		movs	r0, #2
 442 0014 1CE0     		b	.L33
 443              	.LVL23:
 444              	.L32:
 323:usb.c         ****             /* successfull state transition, handle the request */
 445              		.loc 1 323 9 is_stmt 1 view .LVU90
 323:usb.c         ****             /* successfull state transition, handle the request */
 446              		.loc 1 323 13 is_stmt 0 view .LVU91
 447 0016 FFF7FEFF 		bl	dfuUpdateByRequest
 448              	.LVL24:
 323:usb.c         ****             /* successfull state transition, handle the request */
 449              		.loc 1 323 12 view .LVU92
 450 001a 0028     		cmp	r0, #0
 451 001c F9D0     		beq	.L40
 452              	.LVL25:
 453              	.LBB7:
 454              	.LBI7:
 317:usb.c         ****     u8 *(*CopyRoutine)(u16);
 455              		.loc 1 317 8 is_stmt 1 view .LVU93
 456              	.LBB8:
 325:usb.c         ****             case(DFU_GETSTATUS):
 457              		.loc 1 325 13 view .LVU94
 458 001e 601E     		subs	r0, r4, #1
 459 0020 0428     		cmp	r0, #4
 460 0022 F6D8     		bhi	.L40
 461 0024 01A3     		adr	r3, .L36
 462 0026 53F820F0 		ldr	pc, [r3, r0, lsl #2]
 463 002a 00BF     		.p2align 2
 464              	.L36:
 465 002c 53000000 		.word	.L39+1
 466 0030 57000000 		.word	.L38+1
 467 0034 5B000000 		.word	.L41+1
 468 0038 13000000 		.word	.L40+1
 469 003c 41000000 		.word	.L35+1
 470              		.p2align 1
 471              	.L35:
 472              	.LBE8:
 473              	.LBE7:
 323:usb.c         ****             /* successfull state transition, handle the request */
 474              		.loc 1 323 12 is_stmt 0 view .LVU95
 475 0040 084B     		ldr	r3, .L45+4
 476              	.L37:
 477              	.LVL26:
 478              	.LBB11:
 479              	.LBB9:
 345:usb.c         ****         pInformation->Ctrl_Info.CopyData = CopyRoutine;
 480              		.loc 1 345 5 is_stmt 1 view .LVU96
 346:usb.c         ****         pInformation->Ctrl_Info.Usb_wOffset = 0;
 481              		.loc 1 346 9 view .LVU97
 347:usb.c         ****         (*CopyRoutine)(0);
 482              		.loc 1 347 45 is_stmt 0 view .LVU98
 483 0042 0024     		movs	r4, #0
 484              	.LVL27:
 346:usb.c         ****         pInformation->Ctrl_Info.Usb_wOffset = 0;
 485              		.loc 1 346 21 view .LVU99
 486 0044 2A68     		ldr	r2, [r5]
 348:usb.c         **** 
 487              		.loc 1 348 10 view .LVU100
 488 0046 2046     		mov	r0, r4
 346:usb.c         ****         pInformation->Ctrl_Info.Usb_wOffset = 0;
 489              		.loc 1 346 42 view .LVU101
 490 0048 9361     		str	r3, [r2, #24]
 347:usb.c         ****         (*CopyRoutine)(0);
 491              		.loc 1 347 9 is_stmt 1 view .LVU102
 347:usb.c         ****         (*CopyRoutine)(0);
 492              		.loc 1 347 45 is_stmt 0 view .LVU103
 493 004a 5482     		strh	r4, [r2, #18]	@ movhi
 348:usb.c         **** 
 494              		.loc 1 348 9 is_stmt 1 view .LVU104
 348:usb.c         **** 
 495              		.loc 1 348 10 is_stmt 0 view .LVU105
 496 004c 9847     		blx	r3
 497              	.LVL28:
 350:usb.c         ****     }
 498              		.loc 1 350 9 is_stmt 1 view .LVU106
 350:usb.c         ****     }
 499              		.loc 1 350 16 is_stmt 0 view .LVU107
 500 004e 2046     		mov	r0, r4
 501              	.L33:
 502              	.LVL29:
 350:usb.c         ****     }
 503              		.loc 1 350 16 view .LVU108
 504              	.LBE9:
 505              	.LBE11:
 354:usb.c         **** 
 506              		.loc 1 354 1 view .LVU109
 507 0050 38BD     		pop	{r3, r4, r5, pc}
 508              	.LVL30:
 509              	.L39:
 510              	.LBB12:
 511              	.LBB10:
 333:usb.c         ****                 break;
 512              		.loc 1 333 17 is_stmt 1 view .LVU110
 334:usb.c         ****             case(DFU_UPLOAD):
 513              		.loc 1 334 17 view .LVU111
 333:usb.c         ****                 break;
 514              		.loc 1 333 29 is_stmt 0 view .LVU112
 515 0052 054B     		ldr	r3, .L45+8
 334:usb.c         ****             case(DFU_UPLOAD):
 516              		.loc 1 334 17 view .LVU113
 517 0054 F5E7     		b	.L37
 518              	.L38:
 336:usb.c         ****                 break;
 519              		.loc 1 336 17 is_stmt 1 view .LVU114
 337:usb.c         ****             default:
 520              		.loc 1 337 17 view .LVU115
 336:usb.c         ****                 break;
 521              		.loc 1 336 29 is_stmt 0 view .LVU116
 522 0056 054B     		ldr	r3, .L45+12
 337:usb.c         ****             default:
 523              		.loc 1 337 17 view .LVU117
 524 0058 F3E7     		b	.L37
 525              	.L41:
 327:usb.c         ****                 break;
 526              		.loc 1 327 29 view .LVU118
 527 005a 054B     		ldr	r3, .L45+16
 528 005c F1E7     		b	.L37
 529              	.L46:
 530 005e 00BF     		.align	2
 531              	.L45:
 532 0060 00000000 		.word	pInformation
 533 0064 00000000 		.word	dfuCopyState
 534 0068 00000000 		.word	dfuCopyDNLOAD
 535 006c 00000000 		.word	dfuCopyUPLOAD
 536 0070 00000000 		.word	dfuCopyStatus
 537              	.LBE10:
 538              	.LBE12:
 539              		.cfi_endproc
 540              	.LFE13:
 542              		.section	.text.usbNoDataSetup,"ax",%progbits
 543              		.align	1
 544              		.global	usbNoDataSetup
 545              		.syntax unified
 546              		.thumb
 547              		.thumb_func
 548              		.fpu softvfp
 550              	usbNoDataSetup:
 551              	.LVL31:
 552              	.LFB14:
 356:usb.c         ****     if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE
 553              		.loc 1 356 35 is_stmt 1 view -0
 554              		.cfi_startproc
 555              		@ args = 0, pretend = 0, frame = 0
 556              		@ frame_needed = 0, uses_anonymous_args = 0
 357:usb.c         ****         /* todo, keep track of the destination interface, often stored in wIndex */
 557              		.loc 1 357 5 view .LVU120
 356:usb.c         ****     if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE
 558              		.loc 1 356 35 is_stmt 0 view .LVU121
 559 0000 08B5     		push	{r3, lr}
 560              		.cfi_def_cfa_offset 8
 561              		.cfi_offset 3, -8
 562              		.cfi_offset 14, -4
 357:usb.c         ****         /* todo, keep track of the destination interface, often stored in wIndex */
 563              		.loc 1 357 22 view .LVU122
 564 0002 074B     		ldr	r3, .L54
 565 0004 1B68     		ldr	r3, [r3]
 357:usb.c         ****         /* todo, keep track of the destination interface, often stored in wIndex */
 566              		.loc 1 357 8 view .LVU123
 567 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 568 0008 03F07F03 		and	r3, r3, #127
 569 000c 212B     		cmp	r3, #33
 570 000e 01D0     		beq	.L48
 571              	.LVL32:
 572              	.L50:
 363:usb.c         **** }
 573              		.loc 1 363 12 view .LVU124
 574 0010 0220     		movs	r0, #2
 575              	.L49:
 364:usb.c         **** 
 576              		.loc 1 364 1 view .LVU125
 577 0012 08BD     		pop	{r3, pc}
 578              	.LVL33:
 579              	.L48:
 580              	.LBB15:
 581              	.LBI15:
 356:usb.c         ****     if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE
 582              		.loc 1 356 8 is_stmt 1 view .LVU126
 583              	.LBB16:
 359:usb.c         ****             return USB_SUCCESS;
 584              		.loc 1 359 9 view .LVU127
 359:usb.c         ****             return USB_SUCCESS;
 585              		.loc 1 359 13 is_stmt 0 view .LVU128
 586 0014 FFF7FEFF 		bl	dfuUpdateByRequest
 587              	.LVL34:
 359:usb.c         ****             return USB_SUCCESS;
 588              		.loc 1 359 12 view .LVU129
 589 0018 0028     		cmp	r0, #0
 590 001a F9D0     		beq	.L50
 360:usb.c         ****         }
 591              		.loc 1 360 20 view .LVU130
 592 001c 0020     		movs	r0, #0
 593 001e F8E7     		b	.L49
 594              	.L55:
 595              		.align	2
 596              	.L54:
 597 0020 00000000 		.word	pInformation
 598              	.LBE16:
 599              	.LBE15:
 600              		.cfi_endproc
 601              	.LFE14:
 603              		.section	.text.usbSetDeviceFeature,"ax",%progbits
 604              		.align	1
 605              		.global	usbSetDeviceFeature
 606              		.syntax unified
 607              		.thumb
 608              		.thumb_func
 609              		.fpu softvfp
 611              	usbSetDeviceFeature:
 612              	.LFB49:
 613              		.cfi_startproc
 614              		@ args = 0, pretend = 0, frame = 0
 615              		@ frame_needed = 0, uses_anonymous_args = 0
 616              		@ link register save eliminated.
 617 0000 7047     		bx	lr
 618              		.cfi_endproc
 619              	.LFE49:
 621              		.section	.text.nothingProc,"ax",%progbits
 622              		.align	1
 623              		.global	nothingProc
 624              		.syntax unified
 625              		.thumb
 626              		.thumb_func
 627              		.fpu softvfp
 629              	nothingProc:
 630              	.LFB51:
 631              		.cfi_startproc
 632              		@ args = 0, pretend = 0, frame = 0
 633              		@ frame_needed = 0, uses_anonymous_args = 0
 634              		@ link register save eliminated.
 635 0000 7047     		bx	lr
 636              		.cfi_endproc
 637              	.LFE51:
 639              		.section	.text.usbStatusOut,"ax",%progbits
 640              		.align	1
 641              		.global	usbStatusOut
 642              		.syntax unified
 643              		.thumb
 644              		.thumb_func
 645              		.fpu softvfp
 647              	usbStatusOut:
 648              	.LFB35:
 649              		.cfi_startproc
 650              		@ args = 0, pretend = 0, frame = 0
 651              		@ frame_needed = 0, uses_anonymous_args = 0
 652              		@ link register save eliminated.
 653 0000 7047     		bx	lr
 654              		.cfi_endproc
 655              	.LFE35:
 657              		.section	.text.usbGetConfiguration,"ax",%progbits
 658              		.align	1
 659              		.global	usbGetConfiguration
 660              		.syntax unified
 661              		.thumb
 662              		.thumb_func
 663              		.fpu softvfp
 665              	usbGetConfiguration:
 666              	.LFB37:
 667              		.cfi_startproc
 668              		@ args = 0, pretend = 0, frame = 0
 669              		@ frame_needed = 0, uses_anonymous_args = 0
 670              		@ link register save eliminated.
 671 0000 7047     		bx	lr
 672              		.cfi_endproc
 673              	.LFE37:
 675              		.section	.text.usbGetInterface,"ax",%progbits
 676              		.align	1
 677              		.global	usbGetInterface
 678              		.syntax unified
 679              		.thumb
 680              		.thumb_func
 681              		.fpu softvfp
 683              	usbGetInterface:
 684              	.LFB39:
 685              		.cfi_startproc
 686              		@ args = 0, pretend = 0, frame = 0
 687              		@ frame_needed = 0, uses_anonymous_args = 0
 688              		@ link register save eliminated.
 689 0000 7047     		bx	lr
 690              		.cfi_endproc
 691              	.LFE39:
 693              		.section	.text.usbSetInterface,"ax",%progbits
 694              		.align	1
 695              		.global	usbSetInterface
 696              		.syntax unified
 697              		.thumb
 698              		.thumb_func
 699              		.fpu softvfp
 701              	usbSetInterface:
 702              	.LFB41:
 703              		.cfi_startproc
 704              		@ args = 0, pretend = 0, frame = 0
 705              		@ frame_needed = 0, uses_anonymous_args = 0
 706              		@ link register save eliminated.
 707 0000 7047     		bx	lr
 708              		.cfi_endproc
 709              	.LFE41:
 711              		.section	.text.usbGetStatus,"ax",%progbits
 712              		.align	1
 713              		.global	usbGetStatus
 714              		.syntax unified
 715              		.thumb
 716              		.thumb_func
 717              		.fpu softvfp
 719              	usbGetStatus:
 720              	.LFB43:
 721              		.cfi_startproc
 722              		@ args = 0, pretend = 0, frame = 0
 723              		@ frame_needed = 0, uses_anonymous_args = 0
 724              		@ link register save eliminated.
 725 0000 7047     		bx	lr
 726              		.cfi_endproc
 727              	.LFE43:
 729              		.section	.text.usbClearFeature,"ax",%progbits
 730              		.align	1
 731              		.global	usbClearFeature
 732              		.syntax unified
 733              		.thumb
 734              		.thumb_func
 735              		.fpu softvfp
 737              	usbClearFeature:
 738              	.LFB45:
 739              		.cfi_startproc
 740              		@ args = 0, pretend = 0, frame = 0
 741              		@ frame_needed = 0, uses_anonymous_args = 0
 742              		@ link register save eliminated.
 743 0000 7047     		bx	lr
 744              		.cfi_endproc
 745              	.LFE45:
 747              		.section	.text.usbSetEndpointFeature,"ax",%progbits
 748              		.align	1
 749              		.global	usbSetEndpointFeature
 750              		.syntax unified
 751              		.thumb
 752              		.thumb_func
 753              		.fpu softvfp
 755              	usbSetEndpointFeature:
 756              	.LFB47:
 757              		.cfi_startproc
 758              		@ args = 0, pretend = 0, frame = 0
 759              		@ frame_needed = 0, uses_anonymous_args = 0
 760              		@ link register save eliminated.
 761 0000 7047     		bx	lr
 762              		.cfi_endproc
 763              	.LFE47:
 765              		.section	.text.setupUSB,"ax",%progbits
 766              		.align	1
 767              		.global	setupUSB
 768              		.syntax unified
 769              		.thumb
 770              		.thumb_func
 771              		.fpu softvfp
 773              	setupUSB:
 774              	.LFB0:
  40:usb.c         **** 
 775              		.loc 1 40 22 is_stmt 1 view -0
 776              		.cfi_startproc
 777              		@ args = 0, pretend = 0, frame = 8
 778              		@ frame_needed = 0, uses_anonymous_args = 0
  57:usb.c         **** 
 779              		.loc 1 57 5 view .LVU132
  57:usb.c         **** 
 780              		.loc 1 57 5 view .LVU133
  40:usb.c         **** 
 781              		.loc 1 40 22 is_stmt 0 view .LVU134
 782 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 783              		.cfi_def_cfa_offset 24
 784              		.cfi_offset 4, -12
 785              		.cfi_offset 5, -8
 786              		.cfi_offset 14, -4
  57:usb.c         **** 
 787              		.loc 1 57 5 view .LVU135
 788 0002 1B4D     		ldr	r5, .L69
 789 0004 0C20     		movs	r0, #12
 790 0006 D5F80448 		ldr	r4, [r5, #2052]
 791 000a FFF7FEFF 		bl	crMask
 792              	.LVL35:
 793 000e 0440     		ands	r4, r4, r0
 794 0010 44F48034 		orr	r4, r4, #65536
  59:usb.c         **** 
 795              		.loc 1 59 5 view .LVU136
 796 0014 0022     		movs	r2, #0
 797 0016 0C21     		movs	r1, #12
 798 0018 1648     		ldr	r0, .L69+4
  57:usb.c         **** 
 799              		.loc 1 57 5 view .LVU137
 800 001a C5F80448 		str	r4, [r5, #2052]
  57:usb.c         **** 
 801              		.loc 1 57 5 is_stmt 1 view .LVU138
  59:usb.c         **** 
 802              		.loc 1 59 5 view .LVU139
 803 001e FFF7FEFF 		bl	gpio_write_bit
 804              	.LVL36:
  61:usb.c         ****     for(delay = 0;delay<512;delay++);
 805              		.loc 1 61 5 view .LVU140
  62:usb.c         **** 
 806              		.loc 1 62 5 view .LVU141
  62:usb.c         **** 
 807              		.loc 1 62 15 is_stmt 0 view .LVU142
 808 0022 0023     		movs	r3, #0
 809              	.L68:
  62:usb.c         **** 
 810              		.loc 1 62 34 discriminator 3 view .LVU143
 811 0024 0193     		str	r3, [sp, #4]
  62:usb.c         **** 
 812              		.loc 1 62 19 is_stmt 1 discriminator 3 view .LVU144
  62:usb.c         **** 
 813              		.loc 1 62 24 is_stmt 0 discriminator 3 view .LVU145
 814 0026 019B     		ldr	r3, [sp, #4]
  62:usb.c         **** 
 815              		.loc 1 62 5 discriminator 3 view .LVU146
 816 0028 B3F5007F 		cmp	r3, #512
 817 002c 1DD3     		bcc	.L67
  66:usb.c         ****         (GET_REG(GPIO_CR(USB_DISC_BANK,USB_DISC_PIN)) & crMask(USB_DISC_PIN)) | CR_INPUT << CR_SHIT
 818              		.loc 1 66 5 is_stmt 1 view .LVU147
  66:usb.c         ****         (GET_REG(GPIO_CR(USB_DISC_BANK,USB_DISC_PIN)) & crMask(USB_DISC_PIN)) | CR_INPUT << CR_SHIT
 819              		.loc 1 66 5 view .LVU148
 820 002e 0C20     		movs	r0, #12
 821 0030 D5F80448 		ldr	r4, [r5, #2052]
 822 0034 FFF7FEFF 		bl	crMask
 823              	.LVL37:
 824 0038 0440     		ands	r4, r4, r0
 825 003a 44F48024 		orr	r4, r4, #262144
 826 003e C5F80448 		str	r4, [r5, #2052]
  66:usb.c         ****         (GET_REG(GPIO_CR(USB_DISC_BANK,USB_DISC_PIN)) & crMask(USB_DISC_PIN)) | CR_INPUT << CR_SHIT
 827              		.loc 1 66 5 view .LVU149
  72:usb.c         ****     u8_usbConfigDescriptorDFU[41]=(wTransferSize & 0x00FF);
 828              		.loc 1 72 5 view .LVU150
  72:usb.c         ****     u8_usbConfigDescriptorDFU[41]=(wTransferSize & 0x00FF);
 829              		.loc 1 72 19 is_stmt 0 view .LVU151
 830 0042 FFF7FEFF 		bl	getFlashPageSize
 831              	.LVL38:
  72:usb.c         ****     u8_usbConfigDescriptorDFU[41]=(wTransferSize & 0x00FF);
 832              		.loc 1 72 18 view .LVU152
 833 0046 0C4B     		ldr	r3, .L69+8
  73:usb.c         ****     u8_usbConfigDescriptorDFU[42]=(wTransferSize & 0xFF00)>>8;
 834              		.loc 1 73 34 view .LVU153
 835 0048 C2B2     		uxtb	r2, r0
  72:usb.c         ****     u8_usbConfigDescriptorDFU[41]=(wTransferSize & 0x00FF);
 836              		.loc 1 72 18 view .LVU154
 837 004a 1860     		str	r0, [r3]
  73:usb.c         ****     u8_usbConfigDescriptorDFU[42]=(wTransferSize & 0xFF00)>>8;
 838              		.loc 1 73 5 is_stmt 1 view .LVU155
  73:usb.c         ****     u8_usbConfigDescriptorDFU[42]=(wTransferSize & 0xFF00)>>8;
 839              		.loc 1 73 34 is_stmt 0 view .LVU156
 840 004c 0B4B     		ldr	r3, .L69+12
  74:usb.c         **** 
 841              		.loc 1 74 34 view .LVU157
 842 004e C0F30720 		ubfx	r0, r0, #8, #8
  73:usb.c         ****     u8_usbConfigDescriptorDFU[42]=(wTransferSize & 0xFF00)>>8;
 843              		.loc 1 73 34 view .LVU158
 844 0052 83F82920 		strb	r2, [r3, #41]
  74:usb.c         **** 
 845              		.loc 1 74 5 is_stmt 1 view .LVU159
  74:usb.c         **** 
 846              		.loc 1 74 34 is_stmt 0 view .LVU160
 847 0056 83F82A00 		strb	r0, [r3, #42]
  76:usb.c         ****     u8_usbFunctionalDescriptor[6]=(wTransferSize & 0xFF00)>>8;
 848              		.loc 1 76 5 is_stmt 1 view .LVU161
  76:usb.c         ****     u8_usbFunctionalDescriptor[6]=(wTransferSize & 0xFF00)>>8;
 849              		.loc 1 76 34 is_stmt 0 view .LVU162
 850 005a 094B     		ldr	r3, .L69+16
 851 005c 5A71     		strb	r2, [r3, #5]
  77:usb.c         **** 
 852              		.loc 1 77 5 is_stmt 1 view .LVU163
  77:usb.c         **** 
 853              		.loc 1 77 34 is_stmt 0 view .LVU164
 854 005e 9871     		strb	r0, [r3, #6]
  79:usb.c         **** 
 855              		.loc 1 79 5 is_stmt 1 view .LVU165
 856              	.LBB17:
 857              	.LBI17:
 166:usb.c         ****     /* hook in to usb_core, depends on all those damn
 858              		.loc 1 166 6 view .LVU166
 859              	.LBB18:
 169:usb.c         **** }
 860              		.loc 1 169 5 view .LVU167
 861              	.LBE18:
 862              	.LBE17:
  81:usb.c         **** 
 863              		.loc 1 81 1 is_stmt 0 view .LVU168
 864 0060 03B0     		add	sp, sp, #12
 865              		.cfi_remember_state
 866              		.cfi_def_cfa_offset 12
 867              		@ sp needed
 868 0062 BDE83040 		pop	{r4, r5, lr}
 869              		.cfi_restore 14
 870              		.cfi_restore 5
 871              		.cfi_restore 4
 872              		.cfi_def_cfa_offset 0
 873              	.LBB20:
 874              	.LBB19:
 169:usb.c         **** }
 875              		.loc 1 169 5 view .LVU169
 876 0066 FFF7FEBF 		b	USB_Init
 877              	.LVL39:
 878              	.L67:
 879              		.cfi_restore_state
 880              	.LBE19:
 881              	.LBE20:
  62:usb.c         **** 
 882              		.loc 1 62 37 is_stmt 1 discriminator 3 view .LVU170
  62:usb.c         **** 
 883              		.loc 1 62 29 discriminator 3 view .LVU171
  62:usb.c         **** 
 884              		.loc 1 62 34 is_stmt 0 discriminator 3 view .LVU172
 885 006a 019B     		ldr	r3, [sp, #4]
 886 006c 0133     		adds	r3, r3, #1
 887 006e D9E7     		b	.L68
 888              	.L70:
 889              		.align	2
 890              	.L69:
 891 0070 00000140 		.word	1073807360
 892 0074 00080140 		.word	1073809408
 893 0078 00000000 		.word	.LANCHOR1
 894 007c 00000000 		.word	u8_usbConfigDescriptorDFU
 895 0080 00000000 		.word	u8_usbFunctionalDescriptor
 896              		.cfi_endproc
 897              	.LFE0:
 899              		.section	.text.usbAppInit,"ax",%progbits
 900              		.align	1
 901              		.global	usbAppInit
 902              		.syntax unified
 903              		.thumb
 904              		.thumb_func
 905              		.fpu softvfp
 907              	usbAppInit:
 908              	.LFB3:
 166:usb.c         ****     /* hook in to usb_core, depends on all those damn
 909              		.loc 1 166 23 is_stmt 1 view -0
 910              		.cfi_startproc
 911              		@ args = 0, pretend = 0, frame = 0
 912              		@ frame_needed = 0, uses_anonymous_args = 0
 913              		@ link register save eliminated.
 169:usb.c         **** }
 914              		.loc 1 169 5 view .LVU174
 915 0000 FFF7FEBF 		b	USB_Init
 916              	.LVL40:
 917              		.cfi_endproc
 918              	.LFE3:
 920              		.section	.text.usbSuspend,"ax",%progbits
 921              		.align	1
 922              		.global	usbSuspend
 923              		.syntax unified
 924              		.thumb
 925              		.thumb_func
 926              		.fpu softvfp
 928              	usbSuspend:
 929              	.LFB4:
 172:usb.c         ****     u16 wCNTR;
 930              		.loc 1 172 23 view -0
 931              		.cfi_startproc
 932              		@ args = 0, pretend = 0, frame = 0
 933              		@ frame_needed = 0, uses_anonymous_args = 0
 934              		@ link register save eliminated.
 173:usb.c         ****     wCNTR = _GetCNTR();
 935              		.loc 1 173 5 view .LVU176
 174:usb.c         ****     wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
 936              		.loc 1 174 5 view .LVU177
 174:usb.c         ****     wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
 937              		.loc 1 174 13 is_stmt 0 view .LVU178
 938 0000 054A     		ldr	r2, .L73
 939 0002 D2F8403C 		ldr	r3, [r2, #3136]
 174:usb.c         ****     wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
 940              		.loc 1 174 11 view .LVU179
 941 0006 9BB2     		uxth	r3, r3
 942              	.LVL41:
 175:usb.c         ****     _SetCNTR(wCNTR);
 943              		.loc 1 175 5 is_stmt 1 view .LVU180
 176:usb.c         **** 
 944              		.loc 1 176 5 view .LVU181
 945 0008 43F00C03 		orr	r3, r3, #12
 946              	.LVL42:
 176:usb.c         **** 
 947              		.loc 1 176 5 is_stmt 0 view .LVU182
 948 000c C2F8403C 		str	r3, [r2, #3136]
 179:usb.c         **** }
 949              		.loc 1 179 5 is_stmt 1 view .LVU183
 179:usb.c         **** }
 950              		.loc 1 179 18 is_stmt 0 view .LVU184
 951 0010 0322     		movs	r2, #3
 952 0012 024B     		ldr	r3, .L73+4
 953 0014 1A60     		str	r2, [r3]
 180:usb.c         **** 
 954              		.loc 1 180 1 view .LVU185
 955 0016 7047     		bx	lr
 956              	.L74:
 957              		.align	2
 958              	.L73:
 959 0018 00500040 		.word	1073762304
 960 001c 00000000 		.word	.LANCHOR0
 961              		.cfi_endproc
 962              	.LFE4:
 964              		.section	.text.usbResumeInit,"ax",%progbits
 965              		.align	1
 966              		.global	usbResumeInit
 967              		.syntax unified
 968              		.thumb
 969              		.thumb_func
 970              		.fpu softvfp
 972              	usbResumeInit:
 973              	.LFB5:
 182:usb.c         ****     u16 wCNTR;
 974              		.loc 1 182 26 is_stmt 1 view -0
 975              		.cfi_startproc
 976              		@ args = 0, pretend = 0, frame = 0
 977              		@ frame_needed = 0, uses_anonymous_args = 0
 978              		@ link register save eliminated.
 183:usb.c         **** 
 979              		.loc 1 183 5 view .LVU187
 187:usb.c         ****     wCNTR &= (~CNTR_LPMODE);
 980              		.loc 1 187 5 view .LVU188
 189:usb.c         **** 
 981              		.loc 1 189 5 is_stmt 0 view .LVU189
 982 0000 4FF6FB72 		movw	r2, #65531
 187:usb.c         ****     wCNTR &= (~CNTR_LPMODE);
 983              		.loc 1 187 13 view .LVU190
 984 0004 054B     		ldr	r3, .L76
 985 0006 D3F8401C 		ldr	r1, [r3, #3136]
 986              	.LVL43:
 188:usb.c         ****     _SetCNTR(wCNTR);
 987              		.loc 1 188 5 is_stmt 1 view .LVU191
 189:usb.c         **** 
 988              		.loc 1 189 5 view .LVU192
 989 000a 0A40     		ands	r2, r2, r1
 990 000c C3F8402C 		str	r2, [r3, #3136]
 193:usb.c         **** }
 991              		.loc 1 193 5 view .LVU193
 992 0010 4FF43F42 		mov	r2, #48896
 993 0014 C3F8402C 		str	r2, [r3, #3136]
 194:usb.c         **** 
 994              		.loc 1 194 1 is_stmt 0 view .LVU194
 995 0018 7047     		bx	lr
 996              	.L77:
 997 001a 00BF     		.align	2
 998              	.L76:
 999 001c 00500040 		.word	1073762304
 1000              		.cfi_endproc
 1001              	.LFE5:
 1003              		.section	.text.usbResume,"ax",%progbits
 1004              		.align	1
 1005              		.global	usbResume
 1006              		.syntax unified
 1007              		.thumb
 1008              		.thumb_func
 1009              		.fpu softvfp
 1011              	usbResume:
 1012              	.LVL44:
 1013              	.LFB6:
 196:usb.c         ****     u16 wCNTR;
 1014              		.loc 1 196 44 is_stmt 1 view -0
 1015              		.cfi_startproc
 1016              		@ args = 0, pretend = 0, frame = 0
 1017              		@ frame_needed = 0, uses_anonymous_args = 0
 197:usb.c         **** 
 1018              		.loc 1 197 5 view .LVU196
 199:usb.c         ****         ResumeS.eState = eResumeSetVal;
 1019              		.loc 1 199 5 view .LVU197
 196:usb.c         ****     u16 wCNTR;
 1020              		.loc 1 196 44 is_stmt 0 view .LVU198
 1021 0000 10B5     		push	{r4, lr}
 1022              		.cfi_def_cfa_offset 8
 1023              		.cfi_offset 4, -8
 1024              		.cfi_offset 14, -4
 1025 0002 1F4C     		ldr	r4, .L96
 200:usb.c         **** 
 1026              		.loc 1 200 9 is_stmt 1 view .LVU199
 199:usb.c         ****         ResumeS.eState = eResumeSetVal;
 1027              		.loc 1 199 8 is_stmt 0 view .LVU200
 1028 0004 0728     		cmp	r0, #7
 200:usb.c         **** 
 1029              		.loc 1 200 24 view .LVU201
 1030 0006 18BF     		it	ne
 1031 0008 2070     		strbne	r0, [r4]
 202:usb.c         ****     case RESUME_EXTERNAL:
 1032              		.loc 1 202 5 is_stmt 1 view .LVU202
 202:usb.c         ****     case RESUME_EXTERNAL:
 1033              		.loc 1 202 20 is_stmt 0 view .LVU203
 1034 000a 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 1035 000c 052B     		cmp	r3, #5
 1036 000e 06D8     		bhi	.L80
 1037 0010 DFE803F0 		tbb	[pc, r3]
 1038              	.L82:
 1039 0014 03       		.byte	(.L87-.L82)/2
 1040 0015 07       		.byte	(.L86-.L82)/2
 1041 0016 0B       		.byte	(.L85-.L82)/2
 1042 0017 10       		.byte	(.L84-.L82)/2
 1043 0018 18       		.byte	(.L83-.L82)/2
 1044 0019 25       		.byte	(.L81-.L82)/2
 1045              		.p2align 1
 1046              	.L87:
 204:usb.c         ****         ResumeS.eState = RESUME_OFF;
 1047              		.loc 1 204 9 is_stmt 1 view .LVU204
 1048 001a FFF7FEFF 		bl	usbResumeInit
 1049              	.LVL45:
 205:usb.c         ****         break;
 1050              		.loc 1 205 9 view .LVU205
 1051              	.L80:
 239:usb.c         ****         break;
 1052              		.loc 1 239 9 view .LVU206
 239:usb.c         ****         break;
 1053              		.loc 1 239 24 is_stmt 0 view .LVU207
 1054 001e 0623     		movs	r3, #6
 1055 0020 06E0     		b	.L94
 1056              	.L86:
 208:usb.c         ****         ResumeS.eState = RESUME_START;
 1057              		.loc 1 208 9 is_stmt 1 view .LVU208
 1058 0022 FFF7FEFF 		bl	usbResumeInit
 1059              	.LVL46:
 209:usb.c         ****         break;
 1060              		.loc 1 209 9 view .LVU209
 1061              	.L95:
 218:usb.c         ****         break;
 1062              		.loc 1 218 13 view .LVU210
 218:usb.c         ****         break;
 1063              		.loc 1 218 28 is_stmt 0 view .LVU211
 1064 0026 0423     		movs	r3, #4
 1065 0028 02E0     		b	.L94
 1066              	.L85:
 212:usb.c         ****         ResumeS.eState = RESUME_WAIT;
 1067              		.loc 1 212 9 is_stmt 1 view .LVU212
 212:usb.c         ****         ResumeS.eState = RESUME_WAIT;
 1068              		.loc 1 212 26 is_stmt 0 view .LVU213
 1069 002a 0223     		movs	r3, #2
 1070 002c 6370     		strb	r3, [r4, #1]
 213:usb.c         ****         break;
 1071              		.loc 1 213 9 is_stmt 1 view .LVU214
 213:usb.c         ****         break;
 1072              		.loc 1 213 24 is_stmt 0 view .LVU215
 1073 002e 0323     		movs	r3, #3
 1074              	.L94:
 239:usb.c         ****         break;
 1075              		.loc 1 239 24 view .LVU216
 1076 0030 2370     		strb	r3, [r4]
 240:usb.c         ****     }
 1077              		.loc 1 240 9 is_stmt 1 view .LVU217
 242:usb.c         **** 
 1078              		.loc 1 242 1 is_stmt 0 view .LVU218
 1079 0032 06E0     		b	.L78
 1080              	.L84:
 216:usb.c         ****         if (ResumeS.bESOFcnt == 0)
 1081              		.loc 1 216 9 is_stmt 1 view .LVU219
 216:usb.c         ****         if (ResumeS.bESOFcnt == 0)
 1082              		.loc 1 216 16 is_stmt 0 view .LVU220
 1083 0034 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 216:usb.c         ****         if (ResumeS.bESOFcnt == 0)
 1084              		.loc 1 216 25 view .LVU221
 1085 0036 013B     		subs	r3, r3, #1
 1086 0038 DBB2     		uxtb	r3, r3
 1087 003a 6370     		strb	r3, [r4, #1]
 217:usb.c         ****             ResumeS.eState = RESUME_START;
 1088              		.loc 1 217 9 is_stmt 1 view .LVU222
 217:usb.c         ****             ResumeS.eState = RESUME_START;
 1089              		.loc 1 217 20 is_stmt 0 view .LVU223
 1090 003c 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 217:usb.c         ****             ResumeS.eState = RESUME_START;
 1091              		.loc 1 217 12 view .LVU224
 1092 003e 002B     		cmp	r3, #0
 1093 0040 F1D0     		beq	.L95
 1094              	.L78:
 242:usb.c         **** 
 1095              		.loc 1 242 1 view .LVU225
 1096 0042 10BD     		pop	{r4, pc}
 1097              	.L83:
 221:usb.c         ****         wCNTR |= CNTR_RESUME;
 1098              		.loc 1 221 9 is_stmt 1 view .LVU226
 221:usb.c         ****         wCNTR |= CNTR_RESUME;
 1099              		.loc 1 221 17 is_stmt 0 view .LVU227
 1100 0044 0F4A     		ldr	r2, .L96+4
 1101 0046 D2F8403C 		ldr	r3, [r2, #3136]
 221:usb.c         ****         wCNTR |= CNTR_RESUME;
 1102              		.loc 1 221 15 view .LVU228
 1103 004a 9BB2     		uxth	r3, r3
 1104              	.LVL47:
 222:usb.c         ****         _SetCNTR(wCNTR);
 1105              		.loc 1 222 9 is_stmt 1 view .LVU229
 223:usb.c         ****         ResumeS.eState = RESUME_ON;
 1106              		.loc 1 223 9 view .LVU230
 1107 004c 43F01003 		orr	r3, r3, #16
 1108              	.LVL48:
 223:usb.c         ****         ResumeS.eState = RESUME_ON;
 1109              		.loc 1 223 9 is_stmt 0 view .LVU231
 1110 0050 C2F8403C 		str	r3, [r2, #3136]
 224:usb.c         ****         ResumeS.bESOFcnt = 10;
 1111              		.loc 1 224 9 is_stmt 1 view .LVU232
 224:usb.c         ****         ResumeS.bESOFcnt = 10;
 1112              		.loc 1 224 24 is_stmt 0 view .LVU233
 1113 0054 0523     		movs	r3, #5
 1114 0056 2370     		strb	r3, [r4]
 225:usb.c         ****         break;
 1115              		.loc 1 225 9 is_stmt 1 view .LVU234
 225:usb.c         ****         break;
 1116              		.loc 1 225 26 is_stmt 0 view .LVU235
 1117 0058 0A23     		movs	r3, #10
 1118 005a 6370     		strb	r3, [r4, #1]
 226:usb.c         ****     case RESUME_ON:
 1119              		.loc 1 226 9 is_stmt 1 view .LVU236
 1120 005c F1E7     		b	.L78
 1121              	.L81:
 228:usb.c         ****         if (ResumeS.bESOFcnt == 0) {
 1122              		.loc 1 228 9 view .LVU237
 228:usb.c         ****         if (ResumeS.bESOFcnt == 0) {
 1123              		.loc 1 228 16 is_stmt 0 view .LVU238
 1124 005e 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 228:usb.c         ****         if (ResumeS.bESOFcnt == 0) {
 1125              		.loc 1 228 25 view .LVU239
 1126 0060 013B     		subs	r3, r3, #1
 1127 0062 DBB2     		uxtb	r3, r3
 1128 0064 6370     		strb	r3, [r4, #1]
 229:usb.c         ****             wCNTR = _GetCNTR();
 1129              		.loc 1 229 9 is_stmt 1 view .LVU240
 229:usb.c         ****             wCNTR = _GetCNTR();
 1130              		.loc 1 229 20 is_stmt 0 view .LVU241
 1131 0066 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 229:usb.c         ****             wCNTR = _GetCNTR();
 1132              		.loc 1 229 12 view .LVU242
 1133 0068 002B     		cmp	r3, #0
 1134 006a EAD1     		bne	.L78
 230:usb.c         ****             wCNTR &= (~CNTR_RESUME);
 1135              		.loc 1 230 13 is_stmt 1 view .LVU243
 232:usb.c         ****             ResumeS.eState = RESUME_OFF;
 1136              		.loc 1 232 13 is_stmt 0 view .LVU244
 1137 006c 4FF6EF73 		movw	r3, #65519
 230:usb.c         ****             wCNTR &= (~CNTR_RESUME);
 1138              		.loc 1 230 21 view .LVU245
 1139 0070 044A     		ldr	r2, .L96+4
 1140 0072 D2F8401C 		ldr	r1, [r2, #3136]
 1141              	.LVL49:
 231:usb.c         ****             _SetCNTR(wCNTR);
 1142              		.loc 1 231 13 is_stmt 1 view .LVU246
 232:usb.c         ****             ResumeS.eState = RESUME_OFF;
 1143              		.loc 1 232 13 view .LVU247
 1144 0076 0B40     		ands	r3, r3, r1
 1145 0078 C2F8403C 		str	r3, [r2, #3136]
 233:usb.c         ****         }
 1146              		.loc 1 233 13 view .LVU248
 1147 007c CFE7     		b	.L80
 1148              	.L97:
 1149 007e 00BF     		.align	2
 1150              	.L96:
 1151 0080 00000000 		.word	.LANCHOR2
 1152 0084 00500040 		.word	1073762304
 1153              		.cfi_endproc
 1154              	.LFE6:
 1156              		.section	.text.usbPowerOn,"ax",%progbits
 1157              		.align	1
 1158              		.global	usbPowerOn
 1159              		.syntax unified
 1160              		.thumb
 1161              		.thumb_func
 1162              		.fpu softvfp
 1164              	usbPowerOn:
 1165              	.LFB7:
 244:usb.c         ****     u16 wRegVal;
 1166              		.loc 1 244 25 view -0
 1167              		.cfi_startproc
 1168              		@ args = 0, pretend = 0, frame = 0
 1169              		@ frame_needed = 0, uses_anonymous_args = 0
 1170              		@ link register save eliminated.
 245:usb.c         **** 
 1171              		.loc 1 245 5 view .LVU250
 247:usb.c         ****     _SetCNTR(wRegVal);
 1172              		.loc 1 247 5 view .LVU251
 1173              	.LVL50:
 248:usb.c         **** 
 1174              		.loc 1 248 5 view .LVU252
 1175 0000 0122     		movs	r2, #1
 1176 0002 074B     		ldr	r3, .L99
 251:usb.c         ****     _SetISTR(0);
 1177              		.loc 1 251 5 is_stmt 0 view .LVU253
 1178 0004 0020     		movs	r0, #0
 248:usb.c         **** 
 1179              		.loc 1 248 5 view .LVU254
 1180 0006 C3F8402C 		str	r2, [r3, #3136]
 250:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 1181              		.loc 1 250 5 is_stmt 1 view .LVU255
 251:usb.c         ****     _SetISTR(0);
 1182              		.loc 1 251 5 view .LVU256
 253:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 1183              		.loc 1 253 21 is_stmt 0 view .LVU257
 1184 000a 4FF4E052 		mov	r2, #7168
 1185 000e 0549     		ldr	r1, .L99+4
 251:usb.c         ****     _SetISTR(0);
 1186              		.loc 1 251 5 view .LVU258
 1187 0010 C3F8400C 		str	r0, [r3, #3136]
 252:usb.c         ****     wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
 1188              		.loc 1 252 5 is_stmt 1 view .LVU259
 1189 0014 C3F8440C 		str	r0, [r3, #3140]
 253:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 1190              		.loc 1 253 5 view .LVU260
 253:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 1191              		.loc 1 253 21 is_stmt 0 view .LVU261
 1192 0018 0A80     		strh	r2, [r1]	@ movhi
 254:usb.c         **** 
 1193              		.loc 1 254 5 is_stmt 1 view .LVU262
 1194 001a C3F8402C 		str	r2, [r3, #3136]
 256:usb.c         **** }
 1195              		.loc 1 256 5 view .LVU263
 257:usb.c         **** 
 1196              		.loc 1 257 1 is_stmt 0 view .LVU264
 1197 001e 7047     		bx	lr
 1198              	.L100:
 1199              		.align	2
 1200              	.L99:
 1201 0020 00500040 		.word	1073762304
 1202 0024 00000000 		.word	wInterrupt_Mask
 1203              		.cfi_endproc
 1204              	.LFE7:
 1206              		.section	.text.usbPowerOff,"ax",%progbits
 1207              		.align	1
 1208              		.global	usbPowerOff
 1209              		.syntax unified
 1210              		.thumb
 1211              		.thumb_func
 1212              		.fpu softvfp
 1214              	usbPowerOff:
 1215              	.LFB8:
 259:usb.c         ****     _SetCNTR(CNTR_FRES);
 1216              		.loc 1 259 26 is_stmt 1 view -0
 1217              		.cfi_startproc
 1218              		@ args = 0, pretend = 0, frame = 0
 1219              		@ frame_needed = 0, uses_anonymous_args = 0
 1220              		@ link register save eliminated.
 260:usb.c         ****     _SetISTR(0);
 1221              		.loc 1 260 5 view .LVU266
 1222 0000 0122     		movs	r2, #1
 1223 0002 054B     		ldr	r3, .L102
 261:usb.c         ****     _SetCNTR(CNTR_FRES + CNTR_PDWN);
 1224              		.loc 1 261 5 is_stmt 0 view .LVU267
 1225 0004 0020     		movs	r0, #0
 260:usb.c         ****     _SetISTR(0);
 1226              		.loc 1 260 5 view .LVU268
 1227 0006 C3F8402C 		str	r2, [r3, #3136]
 261:usb.c         ****     _SetCNTR(CNTR_FRES + CNTR_PDWN);
 1228              		.loc 1 261 5 is_stmt 1 view .LVU269
 262:usb.c         **** 
 1229              		.loc 1 262 5 is_stmt 0 view .LVU270
 1230 000a 0322     		movs	r2, #3
 261:usb.c         ****     _SetCNTR(CNTR_FRES + CNTR_PDWN);
 1231              		.loc 1 261 5 view .LVU271
 1232 000c C3F8440C 		str	r0, [r3, #3140]
 262:usb.c         **** 
 1233              		.loc 1 262 5 is_stmt 1 view .LVU272
 1234 0010 C3F8402C 		str	r2, [r3, #3136]
 269:usb.c         **** }
 1235              		.loc 1 269 5 view .LVU273
 270:usb.c         **** 
 1236              		.loc 1 270 1 is_stmt 0 view .LVU274
 1237 0014 7047     		bx	lr
 1238              	.L103:
 1239 0016 00BF     		.align	2
 1240              	.L102:
 1241 0018 00500040 		.word	1073762304
 1242              		.cfi_endproc
 1243              	.LFE8:
 1245              		.section	.text.usbDsbBus,"ax",%progbits
 1246              		.align	1
 1247              		.global	usbDsbBus
 1248              		.syntax unified
 1249              		.thumb
 1250              		.thumb_func
 1251              		.fpu softvfp
 1253              	usbDsbBus:
 1254              	.LFB1:
  86:usb.c         **** // setPin(USB_DISC_BANK,USB_DISC_PIN);
 1255              		.loc 1 86 22 is_stmt 1 view -0
 1256              		.cfi_startproc
 1257              		@ args = 0, pretend = 0, frame = 0
 1258              		@ frame_needed = 0, uses_anonymous_args = 0
 1259              		@ link register save eliminated.
  88:usb.c         **** // SET_REG(USB_DISC_CR,
 1260              		.loc 1 88 1 view .LVU276
 1261 0000 FFF7FEBF 		b	usbPowerOff
 1262              	.LVL51:
 1263              		.cfi_endproc
 1264              	.LFE1:
 1266              		.section	.text.usbEnbISR,"ax",%progbits
 1267              		.align	1
 1268              		.global	usbEnbISR
 1269              		.syntax unified
 1270              		.thumb
 1271              		.thumb_func
 1272              		.fpu softvfp
 1274              	usbEnbISR:
 1275              	.LFB29:
 442:usb.c         **** /***** end of USER STANDARD REQUESTS *****/
 443:usb.c         **** 
 444:usb.c         **** 
 445:usb.c         **** void usbEnbISR(void) {
 1276              		.loc 1 445 22 view -0
 1277              		.cfi_startproc
 1278              		@ args = 0, pretend = 0, frame = 8
 1279              		@ frame_needed = 0, uses_anonymous_args = 0
 446:usb.c         ****     NVIC_InitTypeDef NVIC_InitStructure;
 1280              		.loc 1 446 5 view .LVU278
 447:usb.c         **** 
 448:usb.c         **** 
 449:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
 1281              		.loc 1 449 5 view .LVU279
 1282              		.loc 1 449 40 is_stmt 0 view .LVU280
 1283 0000 1423     		movs	r3, #20
 445:usb.c         ****     NVIC_InitTypeDef NVIC_InitStructure;
 1284              		.loc 1 445 22 view .LVU281
 1285 0002 07B5     		push	{r0, r1, r2, lr}
 1286              		.cfi_def_cfa_offset 16
 1287              		.cfi_offset 14, -4
 1288              		.loc 1 449 40 view .LVU282
 1289 0004 8DF80430 		strb	r3, [sp, #4]
 450:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 1290              		.loc 1 450 5 is_stmt 1 view .LVU283
 1291              		.loc 1 450 58 is_stmt 0 view .LVU284
 1292 0008 0023     		movs	r3, #0
 1293 000a 8DF80530 		strb	r3, [sp, #5]
 451:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 1294              		.loc 1 451 5 is_stmt 1 view .LVU285
 1295              		.loc 1 451 51 is_stmt 0 view .LVU286
 1296 000e 8DF80630 		strb	r3, [sp, #6]
 452:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
 1297              		.loc 1 452 5 is_stmt 1 view .LVU287
 1298              		.loc 1 452 43 is_stmt 0 view .LVU288
 1299 0012 0123     		movs	r3, #1
 453:usb.c         ****     nvicInit(&NVIC_InitStructure);
 1300              		.loc 1 453 5 view .LVU289
 1301 0014 01A8     		add	r0, sp, #4
 452:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
 1302              		.loc 1 452 43 view .LVU290
 1303 0016 8DF80730 		strb	r3, [sp, #7]
 1304              		.loc 1 453 5 is_stmt 1 view .LVU291
 1305 001a FFF7FEFF 		bl	nvicInit
 1306              	.LVL52:
 454:usb.c         **** }
 1307              		.loc 1 454 1 is_stmt 0 view .LVU292
 1308 001e 03B0     		add	sp, sp, #12
 1309              		.cfi_def_cfa_offset 4
 1310              		@ sp needed
 1311 0020 5DF804FB 		ldr	pc, [sp], #4
 1312              		.cfi_endproc
 1313              	.LFE29:
 1315              		.section	.text.usbInit,"ax",%progbits
 1316              		.align	1
 1317              		.global	usbInit
 1318              		.syntax unified
 1319              		.thumb
 1320              		.thumb_func
 1321              		.fpu softvfp
 1323              	usbInit:
 1324              	.LFB9:
 272:usb.c         ****     dfuInit();
 1325              		.loc 1 272 20 is_stmt 1 view -0
 1326              		.cfi_startproc
 1327              		@ args = 0, pretend = 0, frame = 0
 1328              		@ frame_needed = 0, uses_anonymous_args = 0
 273:usb.c         **** 
 1329              		.loc 1 273 5 view .LVU294
 272:usb.c         ****     dfuInit();
 1330              		.loc 1 272 20 is_stmt 0 view .LVU295
 1331 0000 10B5     		push	{r4, lr}
 1332              		.cfi_def_cfa_offset 8
 1333              		.cfi_offset 4, -8
 1334              		.cfi_offset 14, -4
 275:usb.c         ****     usbPowerOn();
 1335              		.loc 1 275 41 view .LVU296
 1336 0002 0024     		movs	r4, #0
 273:usb.c         **** 
 1337              		.loc 1 273 5 view .LVU297
 1338 0004 FFF7FEFF 		bl	dfuInit
 1339              	.LVL53:
 275:usb.c         ****     usbPowerOn();
 1340              		.loc 1 275 5 is_stmt 1 view .LVU298
 275:usb.c         ****     usbPowerOn();
 1341              		.loc 1 275 41 is_stmt 0 view .LVU299
 1342 0008 094B     		ldr	r3, .L107
 1343 000a 1B68     		ldr	r3, [r3]
 1344 000c 9C72     		strb	r4, [r3, #10]
 276:usb.c         **** 
 1345              		.loc 1 276 5 is_stmt 1 view .LVU300
 1346 000e FFF7FEFF 		bl	usbPowerOn
 1347              	.LVL54:
 278:usb.c         ****     wInterrupt_Mask = ISR_MSK;
 1348              		.loc 1 278 5 view .LVU301
 279:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 1349              		.loc 1 279 21 is_stmt 0 view .LVU302
 1350 0012 4FF43F42 		mov	r2, #48896
 278:usb.c         ****     wInterrupt_Mask = ISR_MSK;
 1351              		.loc 1 278 5 view .LVU303
 1352 0016 074B     		ldr	r3, .L107+4
 279:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 1353              		.loc 1 279 21 view .LVU304
 1354 0018 0749     		ldr	r1, .L107+8
 278:usb.c         ****     wInterrupt_Mask = ISR_MSK;
 1355              		.loc 1 278 5 view .LVU305
 1356 001a C3F8444C 		str	r4, [r3, #3140]
 279:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 1357              		.loc 1 279 5 is_stmt 1 view .LVU306
 279:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 1358              		.loc 1 279 21 is_stmt 0 view .LVU307
 1359 001e 0A80     		strh	r2, [r1]	@ movhi
 280:usb.c         **** 
 1360              		.loc 1 280 5 is_stmt 1 view .LVU308
 1361 0020 C3F8402C 		str	r2, [r3, #3136]
 282:usb.c         ****     bDeviceState = UNCONNECTED;
 1362              		.loc 1 282 5 view .LVU309
 1363 0024 FFF7FEFF 		bl	usbEnbISR
 1364              	.LVL55:
 283:usb.c         **** }
 1365              		.loc 1 283 5 view .LVU310
 283:usb.c         **** }
 1366              		.loc 1 283 18 is_stmt 0 view .LVU311
 1367 0028 044B     		ldr	r3, .L107+12
 1368 002a 1C60     		str	r4, [r3]
 284:usb.c         **** 
 1369              		.loc 1 284 1 view .LVU312
 1370 002c 10BD     		pop	{r4, pc}
 1371              	.L108:
 1372 002e 00BF     		.align	2
 1373              	.L107:
 1374 0030 00000000 		.word	pInformation
 1375 0034 00500040 		.word	1073762304
 1376 0038 00000000 		.word	wInterrupt_Mask
 1377 003c 00000000 		.word	.LANCHOR0
 1378              		.cfi_endproc
 1379              	.LFE9:
 1381              		.section	.text.usbDsbISR,"ax",%progbits
 1382              		.align	1
 1383              		.global	usbDsbISR
 1384              		.syntax unified
 1385              		.thumb
 1386              		.thumb_func
 1387              		.fpu softvfp
 1389              	usbDsbISR:
 1390              	.LFB30:
 455:usb.c         **** 
 456:usb.c         **** void usbDsbISR(void) {
 1391              		.loc 1 456 22 is_stmt 1 view -0
 1392              		.cfi_startproc
 1393              		@ args = 0, pretend = 0, frame = 8
 1394              		@ frame_needed = 0, uses_anonymous_args = 0
 457:usb.c         ****     NVIC_InitTypeDef NVIC_InitStructure;
 1395              		.loc 1 457 5 view .LVU314
 458:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
 1396              		.loc 1 458 5 view .LVU315
 1397              		.loc 1 458 40 is_stmt 0 view .LVU316
 1398 0000 1423     		movs	r3, #20
 456:usb.c         ****     NVIC_InitTypeDef NVIC_InitStructure;
 1399              		.loc 1 456 22 view .LVU317
 1400 0002 07B5     		push	{r0, r1, r2, lr}
 1401              		.cfi_def_cfa_offset 16
 1402              		.cfi_offset 14, -4
 1403              		.loc 1 458 40 view .LVU318
 1404 0004 8DF80430 		strb	r3, [sp, #4]
 459:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 1405              		.loc 1 459 5 is_stmt 1 view .LVU319
 1406              		.loc 1 459 58 is_stmt 0 view .LVU320
 1407 0008 0023     		movs	r3, #0
 460:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 461:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
 462:usb.c         ****     nvicInit(&NVIC_InitStructure);
 1408              		.loc 1 462 5 view .LVU321
 1409 000a 01A8     		add	r0, sp, #4
 459:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 1410              		.loc 1 459 58 view .LVU322
 1411 000c 8DF80530 		strb	r3, [sp, #5]
 460:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 1412              		.loc 1 460 5 is_stmt 1 view .LVU323
 460:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 1413              		.loc 1 460 51 is_stmt 0 view .LVU324
 1414 0010 8DF80630 		strb	r3, [sp, #6]
 461:usb.c         ****     nvicInit(&NVIC_InitStructure);
 1415              		.loc 1 461 5 is_stmt 1 view .LVU325
 461:usb.c         ****     nvicInit(&NVIC_InitStructure);
 1416              		.loc 1 461 43 is_stmt 0 view .LVU326
 1417 0014 8DF80730 		strb	r3, [sp, #7]
 1418              		.loc 1 462 5 is_stmt 1 view .LVU327
 1419 0018 FFF7FEFF 		bl	nvicInit
 1420              	.LVL56:
 463:usb.c         **** }
 1421              		.loc 1 463 1 is_stmt 0 view .LVU328
 1422 001c 03B0     		add	sp, sp, #12
 1423              		.cfi_def_cfa_offset 4
 1424              		@ sp needed
 1425 001e 5DF804FB 		ldr	pc, [sp], #4
 1426              		.cfi_endproc
 1427              	.LFE30:
 1429              		.section	.text.USB_LP_CAN1_RX0_IRQHandler,"ax",%progbits
 1430              		.align	1
 1431              		.global	USB_LP_CAN1_RX0_IRQHandler
 1432              		.syntax unified
 1433              		.thumb
 1434              		.thumb_func
 1435              		.fpu softvfp
 1437              	USB_LP_CAN1_RX0_IRQHandler:
 1438              	.LFB31:
 464:usb.c         **** 
 465:usb.c         **** void USB_LP_CAN1_RX0_IRQHandler(void) {
 1439              		.loc 1 465 39 is_stmt 1 view -0
 1440              		.cfi_startproc
 1441              		@ args = 0, pretend = 0, frame = 0
 1442              		@ frame_needed = 0, uses_anonymous_args = 0
 466:usb.c         ****     wIstr = _GetISTR();
 1443              		.loc 1 466 5 view .LVU330
 1444              		.loc 1 466 13 is_stmt 0 view .LVU331
 1445 0000 2D4A     		ldr	r2, .L136
 465:usb.c         ****     wIstr = _GetISTR();
 1446              		.loc 1 465 39 view .LVU332
 1447 0002 38B5     		push	{r3, r4, r5, lr}
 1448              		.cfi_def_cfa_offset 16
 1449              		.cfi_offset 3, -16
 1450              		.cfi_offset 4, -12
 1451              		.cfi_offset 5, -8
 1452              		.cfi_offset 14, -4
 1453              		.loc 1 466 13 view .LVU333
 1454 0004 D2F8443C 		ldr	r3, [r2, #3140]
 1455              		.loc 1 466 11 view .LVU334
 1456 0008 2C4C     		ldr	r4, .L136+4
 1457              		.loc 1 466 13 view .LVU335
 1458 000a 9BB2     		uxth	r3, r3
 467:usb.c         **** 
 468:usb.c         ****     /* go nuts with the preproc switches since this is an ISTR and must be FAST */
 469:usb.c         **** #if (ISR_MSK & ISTR_RESET)
 470:usb.c         ****     if (wIstr & ISTR_RESET & wInterrupt_Mask) {
 1459              		.loc 1 470 28 view .LVU336
 1460 000c 2C4D     		ldr	r5, .L136+8
 466:usb.c         **** 
 1461              		.loc 1 466 11 view .LVU337
 1462 000e 2380     		strh	r3, [r4]	@ movhi
 1463              		.loc 1 470 5 is_stmt 1 view .LVU338
 1464              		.loc 1 470 8 is_stmt 0 view .LVU339
 1465 0010 2988     		ldrh	r1, [r5]
 1466              		.loc 1 470 15 view .LVU340
 1467 0012 2388     		ldrh	r3, [r4]
 1468              		.loc 1 470 8 view .LVU341
 1469 0014 0B40     		ands	r3, r3, r1
 1470 0016 5905     		lsls	r1, r3, #21
 1471 0018 06D5     		bpl	.L111
 471:usb.c         ****         _SetISTR((u16)CLR_RESET);
 1472              		.loc 1 471 9 is_stmt 1 view .LVU342
 1473 001a 4FF6FF33 		movw	r3, #64511
 1474 001e C2F8443C 		str	r3, [r2, #3140]
 472:usb.c         ****         Device_Property.Reset();
 1475              		.loc 1 472 9 view .LVU343
 1476              		.loc 1 472 24 is_stmt 0 view .LVU344
 1477 0022 284B     		ldr	r3, .L136+12
 1478              		.loc 1 472 9 view .LVU345
 1479 0024 5B68     		ldr	r3, [r3, #4]
 1480 0026 9847     		blx	r3
 1481              	.LVL57:
 1482              	.L111:
 473:usb.c         ****     }
 474:usb.c         **** #endif
 475:usb.c         **** 
 476:usb.c         **** 
 477:usb.c         **** #if (ISR_MSK & ISTR_DOVR)
 478:usb.c         ****     if (wIstr & ISTR_DOVR & wInterrupt_Mask) {
 479:usb.c         ****         _SetISTR((u16)CLR_DOVR);
 480:usb.c         ****     }
 481:usb.c         **** #endif
 482:usb.c         **** 
 483:usb.c         **** 
 484:usb.c         **** #if (ISR_MSK & ISTR_ERR)
 485:usb.c         ****     if (wIstr & ISTR_ERR & wInterrupt_Mask) {
 1483              		.loc 1 485 5 is_stmt 1 view .LVU346
 1484              		.loc 1 485 15 is_stmt 0 view .LVU347
 1485 0028 2288     		ldrh	r2, [r4]
 1486              		.loc 1 485 26 view .LVU348
 1487 002a 2B88     		ldrh	r3, [r5]
 1488              		.loc 1 485 8 view .LVU349
 1489 002c 1A40     		ands	r2, r2, r3
 1490 002e 9204     		lsls	r2, r2, #18
 486:usb.c         ****         _SetISTR((u16)CLR_ERR);
 1491              		.loc 1 486 9 is_stmt 1 view .LVU350
 1492 0030 42BF     		ittt	mi
 1493 0032 4DF6FF71 		movwmi	r1, #57343
 1494 0036 204A     		ldrmi	r2, .L136
 1495 0038 C2F8441C 		strmi	r1, [r2, #3140]
 487:usb.c         ****     }
 488:usb.c         **** #endif
 489:usb.c         **** 
 490:usb.c         **** 
 491:usb.c         **** #if (ISR_MSK & ISTR_WKUP)
 492:usb.c         ****     if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
 1496              		.loc 1 492 5 view .LVU351
 1497              		.loc 1 492 15 is_stmt 0 view .LVU352
 1498 003c 2288     		ldrh	r2, [r4]
 1499              		.loc 1 492 8 view .LVU353
 1500 003e 1340     		ands	r3, r3, r2
 1501 0040 DB04     		lsls	r3, r3, #19
 1502 0042 07D5     		bpl	.L113
 493:usb.c         ****         _SetISTR((u16)CLR_WKUP);
 1503              		.loc 1 493 9 is_stmt 1 view .LVU354
 1504 0044 4EF6FF72 		movw	r2, #61439
 1505 0048 1B4B     		ldr	r3, .L136
 494:usb.c         ****         usbResume(RESUME_EXTERNAL);
 1506              		.loc 1 494 9 is_stmt 0 view .LVU355
 1507 004a 0020     		movs	r0, #0
 493:usb.c         ****         _SetISTR((u16)CLR_WKUP);
 1508              		.loc 1 493 9 view .LVU356
 1509 004c C3F8442C 		str	r2, [r3, #3140]
 1510              		.loc 1 494 9 is_stmt 1 view .LVU357
 1511 0050 FFF7FEFF 		bl	usbResume
 1512              	.LVL58:
 1513              	.L113:
 495:usb.c         ****     }
 496:usb.c         **** #endif
 497:usb.c         **** 
 498:usb.c         ****     /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
 499:usb.c         **** #if (ISR_MSK & ISTR_SUSP)
 500:usb.c         ****     if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
 1514              		.loc 1 500 5 view .LVU358
 1515              		.loc 1 500 15 is_stmt 0 view .LVU359
 1516 0054 2388     		ldrh	r3, [r4]
 1517              		.loc 1 500 8 view .LVU360
 1518 0056 2A88     		ldrh	r2, [r5]
 1519 0058 1340     		ands	r3, r3, r2
 1520 005a 1805     		lsls	r0, r3, #20
 1521 005c 06D5     		bpl	.L114
 501:usb.c         **** 
 502:usb.c         ****         /* check if SUSPEND is possible */
 503:usb.c         ****         if (F_SUSPEND_ENABLED) {
 1522              		.loc 1 503 9 is_stmt 1 view .LVU361
 504:usb.c         ****             usbSuspend();
 1523              		.loc 1 504 13 view .LVU362
 1524 005e FFF7FEFF 		bl	usbSuspend
 1525              	.LVL59:
 505:usb.c         ****         } else {
 506:usb.c         ****             /* if not possible then resume after xx ms */
 507:usb.c         ****             usbResume(RESUME_LATER);
 508:usb.c         ****         }
 509:usb.c         ****         /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
 510:usb.c         ****         _SetISTR((u16)CLR_SUSP);
 1526              		.loc 1 510 9 view .LVU363
 1527 0062 4FF2FF72 		movw	r2, #63487
 1528 0066 144B     		ldr	r3, .L136
 1529 0068 C3F8442C 		str	r2, [r3, #3140]
 1530              	.L114:
 511:usb.c         ****     }
 512:usb.c         **** #endif
 513:usb.c         **** 
 514:usb.c         **** 
 515:usb.c         **** #if (ISR_MSK & ISTR_SOF)
 516:usb.c         ****     if (wIstr & ISTR_SOF & wInterrupt_Mask) {
 1531              		.loc 1 516 5 view .LVU364
 1532              		.loc 1 516 15 is_stmt 0 view .LVU365
 1533 006c 2388     		ldrh	r3, [r4]
 1534              		.loc 1 516 26 view .LVU366
 1535 006e 2A88     		ldrh	r2, [r5]
 1536              		.loc 1 516 8 view .LVU367
 1537 0070 1340     		ands	r3, r3, r2
 1538 0072 9905     		lsls	r1, r3, #22
 1539 0074 09D5     		bpl	.L115
 517:usb.c         ****         _SetISTR((u16)CLR_SOF);
 1540              		.loc 1 517 9 is_stmt 1 view .LVU368
 1541 0076 4FF6FF51 		movw	r1, #65023
 1542 007a 0F4B     		ldr	r3, .L136
 1543 007c C3F8441C 		str	r1, [r3, #3140]
 518:usb.c         ****         bIntPackSOF++;
 1544              		.loc 1 518 9 view .LVU369
 1545              		.loc 1 518 20 is_stmt 0 view .LVU370
 1546 0080 1149     		ldr	r1, .L136+16
 1547 0082 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 1548 0084 0133     		adds	r3, r3, #1
 1549 0086 DBB2     		uxtb	r3, r3
 1550 0088 0B70     		strb	r3, [r1]
 1551              	.L115:
 519:usb.c         ****     }
 520:usb.c         **** #endif
 521:usb.c         **** 
 522:usb.c         **** 
 523:usb.c         **** #if (ISR_MSK & ISTR_ESOF)
 524:usb.c         ****     if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
 1552              		.loc 1 524 5 is_stmt 1 view .LVU371
 1553              		.loc 1 524 15 is_stmt 0 view .LVU372
 1554 008a 2388     		ldrh	r3, [r4]
 1555              		.loc 1 524 8 view .LVU373
 1556 008c 1A40     		ands	r2, r2, r3
 1557 008e D205     		lsls	r2, r2, #23
 1558 0090 07D5     		bpl	.L116
 525:usb.c         ****         _SetISTR((u16)CLR_ESOF);
 1559              		.loc 1 525 9 is_stmt 1 view .LVU374
 1560 0092 4FF6FF62 		movw	r2, #65279
 1561 0096 084B     		ldr	r3, .L136
 526:usb.c         ****         /* resume handling timing is made with ESOFs */
 527:usb.c         ****         usbResume(RESUME_ESOF); /* request without change of the machine state */
 1562              		.loc 1 527 9 is_stmt 0 view .LVU375
 1563 0098 0720     		movs	r0, #7
 525:usb.c         ****         _SetISTR((u16)CLR_ESOF);
 1564              		.loc 1 525 9 view .LVU376
 1565 009a C3F8442C 		str	r2, [r3, #3140]
 1566              		.loc 1 527 9 is_stmt 1 view .LVU377
 1567 009e FFF7FEFF 		bl	usbResume
 1568              	.LVL60:
 1569              	.L116:
 528:usb.c         ****     }
 529:usb.c         **** #endif
 530:usb.c         **** 
 531:usb.c         ****     /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
 532:usb.c         **** #if (ISR_MSK & ISTR_CTR)
 533:usb.c         ****     if (wIstr & ISTR_CTR & wInterrupt_Mask) {
 1570              		.loc 1 533 5 view .LVU378
 1571              		.loc 1 533 15 is_stmt 0 view .LVU379
 1572 00a2 2388     		ldrh	r3, [r4]
 1573              		.loc 1 533 8 view .LVU380
 1574 00a4 2A88     		ldrh	r2, [r5]
 1575 00a6 1340     		ands	r3, r3, r2
 1576 00a8 1B04     		lsls	r3, r3, #16
 1577 00aa 03D5     		bpl	.L110
 534:usb.c         ****         /* servicing of the endpoint correct transfer interrupt */
 535:usb.c         ****         /* clear of the CTR flag into the sub */
 536:usb.c         ****         CTR_LP(); /* low priority ISR defined in the usb core lib */
 1578              		.loc 1 536 9 is_stmt 1 view .LVU381
 537:usb.c         ****     }
 538:usb.c         **** #endif
 539:usb.c         **** 
 540:usb.c         **** }
 1579              		.loc 1 540 1 is_stmt 0 view .LVU382
 1580 00ac BDE83840 		pop	{r3, r4, r5, lr}
 1581              		.cfi_remember_state
 1582              		.cfi_restore 14
 1583              		.cfi_restore 5
 1584              		.cfi_restore 4
 1585              		.cfi_restore 3
 1586              		.cfi_def_cfa_offset 0
 536:usb.c         ****     }
 1587              		.loc 1 536 9 view .LVU383
 1588 00b0 FFF7FEBF 		b	CTR_LP
 1589              	.LVL61:
 1590              	.L110:
 1591              		.cfi_restore_state
 1592              		.loc 1 540 1 view .LVU384
 1593 00b4 38BD     		pop	{r3, r4, r5, pc}
 1594              	.L137:
 1595 00b6 00BF     		.align	2
 1596              	.L136:
 1597 00b8 00500040 		.word	1073762304
 1598 00bc 00000000 		.word	.LANCHOR3
 1599 00c0 00000000 		.word	wInterrupt_Mask
 1600 00c4 00000000 		.word	.LANCHOR4
 1601 00c8 00000000 		.word	.LANCHOR5
 1602              		.cfi_endproc
 1603              	.LFE31:
 1605              		.global	ResumeS
 1606              		.global	pEpInt_OUT
 1607              		.global	pEpInt_IN
 1608              		.global	User_Standard_Requests
 1609              		.global	Device_Property
 1610              		.global	Device_Table
 1611              		.global	bIntPackSOF
 1612              		.global	wIstr
 1613              		.global	bDeviceState
 1614              		.global	wTransferSize
 1615              		.section	.bss.ResumeS,"aw",%nobits
 1616              		.set	.LANCHOR2,. + 0
 1619              	ResumeS:
 1620 0000 0000     		.space	2
 1621              		.section	.bss.bDeviceState,"aw",%nobits
 1622              		.align	2
 1623              		.set	.LANCHOR0,. + 0
 1626              	bDeviceState:
 1627 0000 00000000 		.space	4
 1628              		.section	.bss.bIntPackSOF,"aw",%nobits
 1629              		.set	.LANCHOR5,. + 0
 1632              	bIntPackSOF:
 1633 0000 00       		.space	1
 1634              		.section	.bss.wIstr,"aw",%nobits
 1635              		.align	1
 1636              		.set	.LANCHOR3,. + 0
 1639              	wIstr:
 1640 0000 0000     		.space	2
 1641              		.section	.bss.wTransferSize,"aw",%nobits
 1642              		.align	2
 1643              		.set	.LANCHOR1,. + 0
 1646              	wTransferSize:
 1647 0000 00000000 		.space	4
 1648              		.section	.data.Device_Property,"aw"
 1649              		.align	2
 1650              		.set	.LANCHOR4,. + 0
 1653              	Device_Property:
 1654 0000 00000000 		.word	usbInit
 1655 0004 00000000 		.word	usbReset
 1656 0008 00000000 		.word	usbStatusIn
 1657 000c 00000000 		.word	usbStatusOut
 1658 0010 00000000 		.word	usbDataSetup
 1659 0014 00000000 		.word	usbNoDataSetup
 1660 0018 00000000 		.word	usbGetInterfaceSetting
 1661 001c 00000000 		.word	usbGetDeviceDescriptor
 1662 0020 00000000 		.word	usbGetConfigDescriptor
 1663 0024 00000000 		.word	usbGetStringDescriptor
 1664 0028 00000000 		.word	usbGetFunctionalDescriptor
 1665 002c 00000000 		.word	0
 1666 0030 40       		.byte	64
 1667 0031 000000   		.space	3
 1668              		.section	.data.Device_Table,"aw"
 1671              	Device_Table:
 1672 0000 01       		.byte	1
 1673 0001 01       		.byte	1
 1674              		.section	.data.User_Standard_Requests,"aw"
 1675              		.align	2
 1678              	User_Standard_Requests:
 1679 0000 00000000 		.word	usbGetConfiguration
 1680 0004 00000000 		.word	usbSetConfiguration
 1681 0008 00000000 		.word	usbGetInterface
 1682 000c 00000000 		.word	usbSetInterface
 1683 0010 00000000 		.word	usbGetStatus
 1684 0014 00000000 		.word	usbClearFeature
 1685 0018 00000000 		.word	usbSetEndpointFeature
 1686 001c 00000000 		.word	usbSetDeviceFeature
 1687 0020 00000000 		.word	usbSetDeviceAddress
 1688              		.section	.data.pEpInt_IN,"aw"
 1689              		.align	2
 1692              	pEpInt_IN:
 1693 0000 00000000 		.word	nothingProc
 1694 0004 00000000 		.word	nothingProc
 1695 0008 00000000 		.word	nothingProc
 1696 000c 00000000 		.word	nothingProc
 1697 0010 00000000 		.word	nothingProc
 1698 0014 00000000 		.word	nothingProc
 1699 0018 00000000 		.word	nothingProc
 1700              		.section	.data.pEpInt_OUT,"aw"
 1701              		.align	2
 1704              	pEpInt_OUT:
 1705 0000 00000000 		.word	nothingProc
 1706 0004 00000000 		.word	nothingProc
 1707 0008 00000000 		.word	nothingProc
 1708 000c 00000000 		.word	nothingProc
 1709 0010 00000000 		.word	nothingProc
 1710 0014 00000000 		.word	nothingProc
 1711 0018 00000000 		.word	nothingProc
 1712              		.text
 1713              	.Letext0:
 1714              		.file 2 "./stm32_lib/stm32f10x_type.h"
 1715              		.file 3 "hardware.h"
 1716              		.file 4 "./usb_lib/usb_core.h"
 1717              		.file 5 "./usb_lib/usb_def.h"
 1718              		.file 6 "./usb_lib/usb_regs.h"
 1719              		.file 7 "./usb_lib/usb_init.h"
 1720              		.file 8 "usb_descriptor.h"
 1721              		.file 9 "usb.h"
 1722              		.file 10 "./usb_lib/usb_int.h"
 1723              		.file 11 "dfu.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 usb.c
D:\QMK_MSYS\tmp\cchG4aZT.s:16     .text.usbStatusIn:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:24     .text.usbStatusIn:0000000000000000 usbStatusIn
D:\QMK_MSYS\tmp\cchG4aZT.s:38     .text.usbGetInterfaceSetting:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:45     .text.usbGetInterfaceSetting:0000000000000000 usbGetInterfaceSetting
D:\QMK_MSYS\tmp\cchG4aZT.s:67     .text.usbSetConfiguration:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:74     .text.usbSetConfiguration:0000000000000000 usbSetConfiguration
D:\QMK_MSYS\tmp\cchG4aZT.s:99     .text.usbSetConfiguration:0000000000000010 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:105    .text.usbSetDeviceAddress:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:112    .text.usbSetDeviceAddress:0000000000000000 usbSetDeviceAddress
D:\QMK_MSYS\tmp\cchG4aZT.s:129    .text.usbSetDeviceAddress:0000000000000008 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:134    .text.usbReset:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:141    .text.usbReset:0000000000000000 usbReset
D:\QMK_MSYS\tmp\cchG4aZT.s:260    .text.usbReset:0000000000000098 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:270    .text.usbGetDeviceDescriptor:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:277    .text.usbGetDeviceDescriptor:0000000000000000 usbGetDeviceDescriptor
D:\QMK_MSYS\tmp\cchG4aZT.s:294    .text.usbGetDeviceDescriptor:0000000000000008 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:299    .text.usbGetConfigDescriptor:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:306    .text.usbGetConfigDescriptor:0000000000000000 usbGetConfigDescriptor
D:\QMK_MSYS\tmp\cchG4aZT.s:323    .text.usbGetConfigDescriptor:0000000000000008 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:328    .text.usbGetStringDescriptor:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:335    .text.usbGetStringDescriptor:0000000000000000 usbGetStringDescriptor
D:\QMK_MSYS\tmp\cchG4aZT.s:368    .text.usbGetStringDescriptor:0000000000000018 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:374    .text.usbGetFunctionalDescriptor:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:381    .text.usbGetFunctionalDescriptor:0000000000000000 usbGetFunctionalDescriptor
D:\QMK_MSYS\tmp\cchG4aZT.s:398    .text.usbGetFunctionalDescriptor:0000000000000008 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:403    .text.usbDataSetup:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:410    .text.usbDataSetup:0000000000000000 usbDataSetup
D:\QMK_MSYS\tmp\cchG4aZT.s:465    .text.usbDataSetup:000000000000002c $d
D:\QMK_MSYS\tmp\cchG4aZT.s:470    .text.usbDataSetup:0000000000000040 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:532    .text.usbDataSetup:0000000000000060 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:543    .text.usbNoDataSetup:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:550    .text.usbNoDataSetup:0000000000000000 usbNoDataSetup
D:\QMK_MSYS\tmp\cchG4aZT.s:597    .text.usbNoDataSetup:0000000000000020 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:604    .text.usbSetDeviceFeature:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:611    .text.usbSetDeviceFeature:0000000000000000 usbSetDeviceFeature
D:\QMK_MSYS\tmp\cchG4aZT.s:622    .text.nothingProc:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:629    .text.nothingProc:0000000000000000 nothingProc
D:\QMK_MSYS\tmp\cchG4aZT.s:640    .text.usbStatusOut:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:647    .text.usbStatusOut:0000000000000000 usbStatusOut
D:\QMK_MSYS\tmp\cchG4aZT.s:658    .text.usbGetConfiguration:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:665    .text.usbGetConfiguration:0000000000000000 usbGetConfiguration
D:\QMK_MSYS\tmp\cchG4aZT.s:676    .text.usbGetInterface:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:683    .text.usbGetInterface:0000000000000000 usbGetInterface
D:\QMK_MSYS\tmp\cchG4aZT.s:694    .text.usbSetInterface:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:701    .text.usbSetInterface:0000000000000000 usbSetInterface
D:\QMK_MSYS\tmp\cchG4aZT.s:712    .text.usbGetStatus:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:719    .text.usbGetStatus:0000000000000000 usbGetStatus
D:\QMK_MSYS\tmp\cchG4aZT.s:730    .text.usbClearFeature:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:737    .text.usbClearFeature:0000000000000000 usbClearFeature
D:\QMK_MSYS\tmp\cchG4aZT.s:748    .text.usbSetEndpointFeature:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:755    .text.usbSetEndpointFeature:0000000000000000 usbSetEndpointFeature
D:\QMK_MSYS\tmp\cchG4aZT.s:766    .text.setupUSB:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:773    .text.setupUSB:0000000000000000 setupUSB
D:\QMK_MSYS\tmp\cchG4aZT.s:891    .text.setupUSB:0000000000000070 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:900    .text.usbAppInit:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:907    .text.usbAppInit:0000000000000000 usbAppInit
D:\QMK_MSYS\tmp\cchG4aZT.s:921    .text.usbSuspend:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:928    .text.usbSuspend:0000000000000000 usbSuspend
D:\QMK_MSYS\tmp\cchG4aZT.s:959    .text.usbSuspend:0000000000000018 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:965    .text.usbResumeInit:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:972    .text.usbResumeInit:0000000000000000 usbResumeInit
D:\QMK_MSYS\tmp\cchG4aZT.s:999    .text.usbResumeInit:000000000000001c $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1004   .text.usbResume:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:1011   .text.usbResume:0000000000000000 usbResume
D:\QMK_MSYS\tmp\cchG4aZT.s:1039   .text.usbResume:0000000000000014 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1045   .text.usbResume:000000000000001a $t
D:\QMK_MSYS\tmp\cchG4aZT.s:1151   .text.usbResume:0000000000000080 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1157   .text.usbPowerOn:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:1164   .text.usbPowerOn:0000000000000000 usbPowerOn
D:\QMK_MSYS\tmp\cchG4aZT.s:1201   .text.usbPowerOn:0000000000000020 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1207   .text.usbPowerOff:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:1214   .text.usbPowerOff:0000000000000000 usbPowerOff
D:\QMK_MSYS\tmp\cchG4aZT.s:1241   .text.usbPowerOff:0000000000000018 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1246   .text.usbDsbBus:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:1253   .text.usbDsbBus:0000000000000000 usbDsbBus
D:\QMK_MSYS\tmp\cchG4aZT.s:1267   .text.usbEnbISR:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:1274   .text.usbEnbISR:0000000000000000 usbEnbISR
D:\QMK_MSYS\tmp\cchG4aZT.s:1316   .text.usbInit:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:1323   .text.usbInit:0000000000000000 usbInit
D:\QMK_MSYS\tmp\cchG4aZT.s:1374   .text.usbInit:0000000000000030 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1382   .text.usbDsbISR:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:1389   .text.usbDsbISR:0000000000000000 usbDsbISR
D:\QMK_MSYS\tmp\cchG4aZT.s:1430   .text.USB_LP_CAN1_RX0_IRQHandler:0000000000000000 $t
D:\QMK_MSYS\tmp\cchG4aZT.s:1437   .text.USB_LP_CAN1_RX0_IRQHandler:0000000000000000 USB_LP_CAN1_RX0_IRQHandler
D:\QMK_MSYS\tmp\cchG4aZT.s:1597   .text.USB_LP_CAN1_RX0_IRQHandler:00000000000000b8 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1619   .bss.ResumeS:0000000000000000 ResumeS
D:\QMK_MSYS\tmp\cchG4aZT.s:1704   .data.pEpInt_OUT:0000000000000000 pEpInt_OUT
D:\QMK_MSYS\tmp\cchG4aZT.s:1692   .data.pEpInt_IN:0000000000000000 pEpInt_IN
D:\QMK_MSYS\tmp\cchG4aZT.s:1678   .data.User_Standard_Requests:0000000000000000 User_Standard_Requests
D:\QMK_MSYS\tmp\cchG4aZT.s:1653   .data.Device_Property:0000000000000000 Device_Property
D:\QMK_MSYS\tmp\cchG4aZT.s:1671   .data.Device_Table:0000000000000000 Device_Table
D:\QMK_MSYS\tmp\cchG4aZT.s:1632   .bss.bIntPackSOF:0000000000000000 bIntPackSOF
D:\QMK_MSYS\tmp\cchG4aZT.s:1639   .bss.wIstr:0000000000000000 wIstr
D:\QMK_MSYS\tmp\cchG4aZT.s:1626   .bss.bDeviceState:0000000000000000 bDeviceState
D:\QMK_MSYS\tmp\cchG4aZT.s:1646   .bss.wTransferSize:0000000000000000 wTransferSize
D:\QMK_MSYS\tmp\cchG4aZT.s:1620   .bss.ResumeS:0000000000000000 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1622   .bss.bDeviceState:0000000000000000 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1633   .bss.bIntPackSOF:0000000000000000 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1635   .bss.wIstr:0000000000000000 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1642   .bss.wTransferSize:0000000000000000 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1649   .data.Device_Property:0000000000000000 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1675   .data.User_Standard_Requests:0000000000000000 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1689   .data.pEpInt_IN:0000000000000000 $d
D:\QMK_MSYS\tmp\cchG4aZT.s:1701   .data.pEpInt_OUT:0000000000000000 $d

UNDEFINED SYMBOLS
pInformation
dfuUpdateByReset
Clear_Status_Out
SetEPRxCount
SetEPRxValid
SetDeviceAddress
usbConfigDescriptorDFU
pProperty
Standard_GetDescriptorData
usbDeviceDescriptorDFU
usbStringDescriptor
usbFunctionalDescriptor
dfuUpdateByRequest
dfuCopyState
dfuCopyDNLOAD
dfuCopyUPLOAD
dfuCopyStatus
crMask
gpio_write_bit
getFlashPageSize
USB_Init
u8_usbConfigDescriptorDFU
u8_usbFunctionalDescriptor
wInterrupt_Mask
nvicInit
dfuInit
CTR_LP
