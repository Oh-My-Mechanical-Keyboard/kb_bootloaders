   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"dfu.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.dfuInit,"ax",%progbits
  16              		.align	1
  17              		.global	dfuInit
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	dfuInit:
  25              	.LFB0:
  26              		.file 1 "dfu.c"
   1:dfu.c         **** /* *****************************************************************************
   2:dfu.c         ****  * The MIT License
   3:dfu.c         ****  *
   4:dfu.c         ****  * Copyright (c) 2010 LeafLabs LLC.
   5:dfu.c         ****  *
   6:dfu.c         ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:dfu.c         ****  * of this software and associated documentation files (the "Software"), to deal
   8:dfu.c         ****  * in the Software without restriction, including without limitation the rights
   9:dfu.c         ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:dfu.c         ****  * copies of the Software, and to permit persons to whom the Software is
  11:dfu.c         ****  * furnished to do so, subject to the following conditions:
  12:dfu.c         ****  *
  13:dfu.c         ****  * The above copyright notice and this permission notice shall be included in
  14:dfu.c         ****  * all copies or substantial portions of the Software.
  15:dfu.c         ****  *
  16:dfu.c         ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:dfu.c         ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:dfu.c         ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:dfu.c         ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:dfu.c         ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:dfu.c         ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:dfu.c         ****  * THE SOFTWARE.
  23:dfu.c         ****  * ****************************************************************************/
  24:dfu.c         **** 
  25:dfu.c         **** /**
  26:dfu.c         ****  *  @file dfu.c
  27:dfu.c         ****  *
  28:dfu.c         ****  *  @brief The principle dfu state machine as well as the data
  29:dfu.c         ****  *  transfer callbacks accessed by the usb library
  30:dfu.c         ****  *
  31:dfu.c         ****  *
  32:dfu.c         ****  */
  33:dfu.c         **** #include "hardware.h"
  34:dfu.c         **** #include "dfu.h"
  35:dfu.c         **** #include "usb.h"
  36:dfu.c         **** 
  37:dfu.c         **** /* DFU globals */
  38:dfu.c         **** static volatile u32 userAppAddr = USER_CODE_RAM; /* default RAM user code location */
  39:dfu.c         **** static volatile u32 userAppEnd = RAM_END;
  40:dfu.c         **** static volatile DFUStatus dfuAppStatus;       /* includes state */
  41:dfu.c         **** volatile dfuUploadTypes_t userUploadType = DFU_UPLOAD_NONE;
  42:dfu.c         **** volatile bool dfuBusy = FALSE;
  43:dfu.c         **** 
  44:dfu.c         **** 
  45:dfu.c         **** //static volatile u8 recvBuffer[wTransferSize] __attribute__((aligned(4)));
  46:dfu.c         **** static volatile u8 recvBuffer[LARGEST_FLASH_PAGE_SIZE] __attribute__((aligned(4)));
  47:dfu.c         **** 
  48:dfu.c         **** static volatile u32 userFirmwareLen = 0;
  49:dfu.c         **** static volatile u16 thisBlockLen = 0;
  50:dfu.c         **** static volatile u16 uploadBlockLen = 0;
  51:dfu.c         **** 
  52:dfu.c         **** 
  53:dfu.c         **** volatile PLOT code_copy_lock;
  54:dfu.c         **** 
  55:dfu.c         **** /* todo: force dfu globals to be singleton to avoid re-inits? */
  56:dfu.c         **** void dfuInit(void) {
  27              		.loc 1 56 20 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  57:dfu.c         ****     dfuAppStatus.bStatus = OK;
  32              		.loc 1 57 5 view .LVU1
  33              		.loc 1 57 26 is_stmt 0 view .LVU2
  34 0000 0023     		movs	r3, #0
  58:dfu.c         ****     dfuAppStatus.bwPollTimeout0 = 0x00;
  59:dfu.c         ****     dfuAppStatus.bwPollTimeout1 = 0x00;
  60:dfu.c         ****     dfuAppStatus.bwPollTimeout2 = 0x00;
  61:dfu.c         ****     dfuAppStatus.bState = dfuIDLE;
  35              		.loc 1 61 25 view .LVU3
  36 0002 0221     		movs	r1, #2
  57:dfu.c         ****     dfuAppStatus.bStatus = OK;
  37              		.loc 1 57 26 view .LVU4
  38 0004 0C4A     		ldr	r2, .L2
  39 0006 1370     		strb	r3, [r2]
  58:dfu.c         ****     dfuAppStatus.bwPollTimeout0 = 0x00;
  40              		.loc 1 58 5 is_stmt 1 view .LVU5
  58:dfu.c         ****     dfuAppStatus.bwPollTimeout0 = 0x00;
  41              		.loc 1 58 33 is_stmt 0 view .LVU6
  42 0008 5370     		strb	r3, [r2, #1]
  59:dfu.c         ****     dfuAppStatus.bwPollTimeout2 = 0x00;
  43              		.loc 1 59 5 is_stmt 1 view .LVU7
  59:dfu.c         ****     dfuAppStatus.bwPollTimeout2 = 0x00;
  44              		.loc 1 59 33 is_stmt 0 view .LVU8
  45 000a 9370     		strb	r3, [r2, #2]
  60:dfu.c         ****     dfuAppStatus.bState = dfuIDLE;
  46              		.loc 1 60 5 is_stmt 1 view .LVU9
  60:dfu.c         ****     dfuAppStatus.bState = dfuIDLE;
  47              		.loc 1 60 33 is_stmt 0 view .LVU10
  48 000c D370     		strb	r3, [r2, #3]
  49              		.loc 1 61 5 is_stmt 1 view .LVU11
  50              		.loc 1 61 25 is_stmt 0 view .LVU12
  51 000e 1171     		strb	r1, [r2, #4]
  62:dfu.c         ****     dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
  52              		.loc 1 62 5 is_stmt 1 view .LVU13
  53              		.loc 1 62 26 is_stmt 0 view .LVU14
  54 0010 5371     		strb	r3, [r2, #5]
  63:dfu.c         ****     userFirmwareLen = 0;
  55              		.loc 1 63 5 is_stmt 1 view .LVU15
  56              		.loc 1 63 21 is_stmt 0 view .LVU16
  57 0012 0A4A     		ldr	r2, .L2+4
  64:dfu.c         ****     thisBlockLen = 0;;
  65:dfu.c         ****     userAppAddr = USER_CODE_RAM; /* default RAM user code location */
  58              		.loc 1 65 17 view .LVU17
  59 0014 0A49     		ldr	r1, .L2+8
  63:dfu.c         ****     userFirmwareLen = 0;
  60              		.loc 1 63 21 view .LVU18
  61 0016 1360     		str	r3, [r2]
  64:dfu.c         ****     thisBlockLen = 0;;
  62              		.loc 1 64 5 is_stmt 1 view .LVU19
  64:dfu.c         ****     thisBlockLen = 0;;
  63              		.loc 1 64 18 is_stmt 0 view .LVU20
  64 0018 0A4A     		ldr	r2, .L2+12
  65 001a 1380     		strh	r3, [r2]	@ movhi
  64:dfu.c         ****     thisBlockLen = 0;;
  66              		.loc 1 64 22 is_stmt 1 view .LVU21
  67              		.loc 1 65 5 view .LVU22
  68              		.loc 1 65 17 is_stmt 0 view .LVU23
  69 001c 0A4A     		ldr	r2, .L2+16
  70 001e 1160     		str	r1, [r2]
  66:dfu.c         ****     userAppEnd = RAM_END;
  71              		.loc 1 66 5 is_stmt 1 view .LVU24
  72              		.loc 1 66 16 is_stmt 0 view .LVU25
  73 0020 0A4A     		ldr	r2, .L2+20
  74 0022 01F58841 		add	r1, r1, #17408
  75 0026 1160     		str	r1, [r2]
  67:dfu.c         ****     userUploadType=DFU_UPLOAD_NONE;
  76              		.loc 1 67 5 is_stmt 1 view .LVU26
  68:dfu.c         ****     code_copy_lock = WAIT;
  77              		.loc 1 68 20 is_stmt 0 view .LVU27
  78 0028 0321     		movs	r1, #3
  67:dfu.c         ****     userUploadType=DFU_UPLOAD_NONE;
  79              		.loc 1 67 19 view .LVU28
  80 002a 094A     		ldr	r2, .L2+24
  81 002c 1370     		strb	r3, [r2]
  82              		.loc 1 68 5 is_stmt 1 view .LVU29
  83              		.loc 1 68 20 is_stmt 0 view .LVU30
  84 002e 094A     		ldr	r2, .L2+28
  85 0030 1170     		strb	r1, [r2]
  69:dfu.c         ****     dfuBusy = FALSE;
  86              		.loc 1 69 5 is_stmt 1 view .LVU31
  87              		.loc 1 69 13 is_stmt 0 view .LVU32
  88 0032 094A     		ldr	r2, .L2+32
  89 0034 1370     		strb	r3, [r2]
  70:dfu.c         **** }
  90              		.loc 1 70 1 view .LVU33
  91 0036 7047     		bx	lr
  92              	.L3:
  93              		.align	2
  94              	.L2:
  95 0038 00000000 		.word	.LANCHOR0
  96 003c 00000000 		.word	.LANCHOR1
  97 0040 000C0020 		.word	536873984
  98 0044 00000000 		.word	.LANCHOR2
  99 0048 00000000 		.word	.LANCHOR3
 100 004c 00000000 		.word	.LANCHOR4
 101 0050 00000000 		.word	.LANCHOR5
 102 0054 00000000 		.word	.LANCHOR6
 103 0058 00000000 		.word	.LANCHOR7
 104              		.cfi_endproc
 105              	.LFE0:
 107              		.section	.text.dfuUpdateByReset,"ax",%progbits
 108              		.align	1
 109              		.global	dfuUpdateByReset
 110              		.syntax unified
 111              		.thumb
 112              		.thumb_func
 113              		.fpu softvfp
 115              	dfuUpdateByReset:
 116              	.LFB2:
  71:dfu.c         **** 
  72:dfu.c         **** 
  73:dfu.c         **** 
  74:dfu.c         **** 
  75:dfu.c         **** bool dfuUpdateByRequest(void) {
  76:dfu.c         ****     /* were using the global pInformation struct from usb_lib here,
  77:dfu.c         ****        see comment in maple_dfu.h around DFUEvent struct */
  78:dfu.c         ****     dfuBusy = TRUE;
  79:dfu.c         **** 
  80:dfu.c         **** 
  81:dfu.c         **** 
  82:dfu.c         ****     u8 startState = dfuAppStatus.bState;
  83:dfu.c         ****     dfuAppStatus.bStatus = OK;
  84:dfu.c         ****     /* often leaner to nest if's then embed a switch/case */
  85:dfu.c         ****     if (startState == dfuIDLE)  {
  86:dfu.c         ****         /*  device running inside DFU mode */
  87:dfu.c         ****         dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
  88:dfu.c         **** 
  89:dfu.c         ****         if (pInformation->USBbRequest == DFU_DNLOAD) {
  90:dfu.c         **** 
  91:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
  92:dfu.c         ****                 userFirmwareLen = 0;
  93:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
  94:dfu.c         ****                 switch(pInformation->Current_AlternateSetting)
  95:dfu.c         ****                 {
  96:dfu.c         ****                     /*
  97:dfu.c         ****                     Roger Clark. removed upload to RAM option
  98:dfu.c         ****                     case 0:
  99:dfu.c         ****                         userAppAddr = USER_CODE_RAM;
 100:dfu.c         ****                         userUploadType = DFU_UPLOAD_RAM;
 101:dfu.c         ****                         break;
 102:dfu.c         ****                         */
 103:dfu.c         ****                     case 1:
 104:dfu.c         **** 
 105:dfu.c         ****                         userAppAddr = USER_CODE_FLASH0X8005000;
 106:dfu.c         ****                         userUploadType = DFU_UPLOAD_FLASH_0X8005000;
 107:dfu.c         **** 
 108:dfu.c         ****                         /* make sure the flash is setup properly, unlock it */
 109:dfu.c         ****                         setupFLASH();
 110:dfu.c         ****                         flashUnlock();
 111:dfu.c         ****                         // Clear lower memory so that we can check on cold boot, whether the last u
 112:dfu.c         ****                         flashErasePage((u32)USER_CODE_FLASH0X8002000);
 113:dfu.c         ****                         bkp10Write(RTC_BOOTLOADER_JUST_UPLOADED);
 114:dfu.c         **** 
 115:dfu.c         ****                         break;
 116:dfu.c         ****                     case 2:
 117:dfu.c         ****                         userUploadType = DFU_UPLOAD_FLASH_0X8002000;
 118:dfu.c         ****                         userAppAddr = USER_CODE_FLASH0X8002000;
 119:dfu.c         ****                         /* make sure the flash is setup properly, unlock it */
 120:dfu.c         ****                         setupFLASH();
 121:dfu.c         ****                         flashUnlock();
 122:dfu.c         ****                         bkp10Write(RTC_BOOTLOADER_JUST_UPLOADED);
 123:dfu.c         **** 
 124:dfu.c         ****                         break;
 125:dfu.c         ****                     default:
 126:dfu.c         ****                     // Roger Clark. Report error
 127:dfu.c         ****                         dfuAppStatus.bState  = dfuERROR;
 128:dfu.c         ****                         dfuAppStatus.bStatus = errWRITE;
 129:dfu.c         ****                         break;
 130:dfu.c         ****                 }
 131:dfu.c         ****             } else {
 132:dfu.c         ****                 dfuAppStatus.bState  = dfuERROR;
 133:dfu.c         ****                 dfuAppStatus.bStatus = errNOTDONE;
 134:dfu.c         ****             }
 135:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_UPLOAD) {
 136:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 137:dfu.c         ****             /* record length of first block for calculating target
 138:dfu.c         ****                address from wValue in consecutive blocks */
 139:dfu.c         ****             uploadBlockLen = pInformation->USBwLengths.w;
 140:dfu.c         ****             thisBlockLen = uploadBlockLen; /* for this first block as well */
 141:dfu.c         ****             /* calculate where the data should be copied from */
 142:dfu.c         ****             userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 143:dfu.c         ****             switch(pInformation->Current_AlternateSetting)
 144:dfu.c         ****             {
 145:dfu.c         ****             /*
 146:dfu.c         ****                 case 0:
 147:dfu.c         ****                     userAppAddr = USER_CODE_RAM;
 148:dfu.c         ****                     userAppEnd = RAM_END;
 149:dfu.c         ****                     */
 150:dfu.c         ****                 case 1:
 151:dfu.c         ****                     userAppAddr = USER_CODE_FLASH0X8005000;
 152:dfu.c         ****                     userAppEnd = getFlashEnd();
 153:dfu.c         ****                     break;
 154:dfu.c         ****                 case 2:
 155:dfu.c         ****                     userAppAddr = USER_CODE_FLASH0X8002000;
 156:dfu.c         ****                     userAppEnd = getFlashEnd();
 157:dfu.c         ****                     break;
 158:dfu.c         ****                 default:
 159:dfu.c         ****                 // Roger Clark.
 160:dfu.c         ****                 // Changed this to report error that its unable to write to this memory
 161:dfu.c         ****                 // However the code should never get here as only AlternateSetting 1 and 2 are allo
 162:dfu.c         ****                     dfuAppStatus.bState  = dfuERROR;
 163:dfu.c         ****                     dfuAppStatus.bStatus = errWRITE;
 164:dfu.c         ****                     break;
 165:dfu.c         ****             }
 166:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 167:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 168:dfu.c         ****             dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
 169:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 170:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 171:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 172:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 173:dfu.c         ****         } else {
 174:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 175:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 176:dfu.c         ****         }
 177:dfu.c         **** 
 178:dfu.c         ****     } else if (startState == dfuDNLOAD_SYNC)         {
 179:dfu.c         ****         /* device received block, waiting for DFU_GETSTATUS request */
 180:dfu.c         **** 
 181:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 182:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 183:dfu.c         **** 
 184:dfu.c         ****             /* Roger Clark. Commented out code associated with RAM upload
 185:dfu.c         **** 
 186:dfu.c         ****             if (userUploadType == DFU_UPLOAD_RAM)
 187:dfu.c         ****             {
 188:dfu.c         ****                 if (code_copy_lock == WAIT) {
 189:dfu.c         ****                     code_copy_lock = BEGINNING;
 190:dfu.c         ****                     dfuAppStatus.bwPollTimeout0 = 0x20; // 32 ms
 191:dfu.c         ****                     dfuAppStatus.bwPollTimeout1 = 0x00;
 192:dfu.c         ****                     dfuAppStatus.bState = dfuDNBUSY;
 193:dfu.c         **** 
 194:dfu.c         ****                 } else if (code_copy_lock == BEGINNING) {
 195:dfu.c         ****                     dfuAppStatus.bState = dfuDNLOAD_SYNC;
 196:dfu.c         **** 
 197:dfu.c         ****                 } else if (code_copy_lock == MIDDLE) {
 198:dfu.c         ****                     dfuAppStatus.bState = dfuDNLOAD_SYNC;
 199:dfu.c         **** 
 200:dfu.c         ****                 } else if (code_copy_lock == END) {
 201:dfu.c         ****                     dfuAppStatus.bwPollTimeout0 = 0x00;
 202:dfu.c         ****                     code_copy_lock = WAIT;
 203:dfu.c         ****                     dfuAppStatus.bState = dfuDNLOAD_IDLE;
 204:dfu.c         ****                 }
 205:dfu.c         **** 
 206:dfu.c         ****             }
 207:dfu.c         ****             else
 208:dfu.c         ****             */
 209:dfu.c         ****             {
 210:dfu.c         ****                 dfuAppStatus.bState = dfuDNLOAD_IDLE;
 211:dfu.c         ****                 dfuCopyBufferToExec();
 212:dfu.c         ****             }
 213:dfu.c         **** 
 214:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 215:dfu.c         ****             dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 216:dfu.c         ****         } else {
 217:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 218:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 219:dfu.c         ****         }
 220:dfu.c         **** 
 221:dfu.c         ****     } else if (startState == dfuDNBUSY)              {
 222:dfu.c         ****         /* if were actually done writing, goto sync, else stay busy */
 223:dfu.c         ****         if (code_copy_lock == END) {
 224:dfu.c         ****             dfuAppStatus.bwPollTimeout0 = 0x00;
 225:dfu.c         ****             code_copy_lock = WAIT;
 226:dfu.c         ****             dfuAppStatus.bState = dfuDNLOAD_IDLE;
 227:dfu.c         ****         } else {
 228:dfu.c         ****             dfuAppStatus.bState = dfuDNBUSY;
 229:dfu.c         ****         }
 230:dfu.c         **** 
 231:dfu.c         ****     } else if (startState == dfuDNLOAD_IDLE)         {
 232:dfu.c         ****         /* device is expecting dfu_dnload requests */
 233:dfu.c         ****         if (pInformation->USBbRequest == DFU_DNLOAD) {
 234:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 235:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 236:dfu.c         ****             } else {
 237:dfu.c         ****                 /* todo, support "disagreement" if device expects more data than this */
 238:dfu.c         ****                 dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 239:dfu.c         **** 
 240:dfu.c         ****                 /* relock the flash */
 241:dfu.c         ****                 flashLock();
 242:dfu.c         ****             }
 243:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 244:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 245:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 246:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 247:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 248:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 249:dfu.c         ****         } else {
 250:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 251:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 252:dfu.c         ****         }
 253:dfu.c         **** 
 254:dfu.c         ****     } else if (startState == dfuMANIFEST_SYNC)       {
 255:dfu.c         ****         /* device has received last block, waiting DFU_GETSTATUS request */
 256:dfu.c         **** 
 257:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 258:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 259:dfu.c         ****             dfuAppStatus.bStatus = OK;
 260:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 261:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 262:dfu.c         ****         } else {
 263:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 264:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 265:dfu.c         ****         }
 266:dfu.c         **** 
 267:dfu.c         ****     } else if (startState == dfuMANIFEST)            {
 268:dfu.c         ****         /* device is in manifestation phase */
 269:dfu.c         **** 
 270:dfu.c         ****         /* should never receive request while in manifest! */
 271:dfu.c         ****         dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 272:dfu.c         ****         dfuAppStatus.bStatus = OK;
 273:dfu.c         **** 
 274:dfu.c         ****     } else if (startState == dfuMANIFEST_WAIT_RESET) {
 275:dfu.c         ****         /* device has programmed new firmware but needs external
 276:dfu.c         ****            usb reset or power on reset to run the new code */
 277:dfu.c         **** 
 278:dfu.c         ****         /* consider timing out and self-resetting */
 279:dfu.c         ****         dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 280:dfu.c         **** 
 281:dfu.c         ****     } else if (startState == dfuUPLOAD_IDLE)         {
 282:dfu.c         ****         /* device expecting further dfu_upload requests */
 283:dfu.c         **** 
 284:dfu.c         ****         if (pInformation->USBbRequest == DFU_UPLOAD) {
 285:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 286:dfu.c         ****                 /* check that this is not the last possible block */
 287:dfu.c         ****                 userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 288:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 289:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 290:dfu.c         ****                     dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 291:dfu.c         ****                 } else {
 292:dfu.c         ****                     /* if above comparison was just equal, thisBlockLen becomes zero
 293:dfu.c         ****                     next time when USBWValue has been increased by one */
 294:dfu.c         ****                     thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
 295:dfu.c         ****                     /* check for overflow due to USBwValue out of range */
 296:dfu.c         ****                     if (thisBlockLen >= pInformation->USBwLengths.w) {
 297:dfu.c         ****                         thisBlockLen = 0;
 298:dfu.c         ****                     }
 299:dfu.c         ****                     dfuAppStatus.bState  = dfuIDLE;
 300:dfu.c         ****                 }
 301:dfu.c         ****             } else {
 302:dfu.c         ****                 dfuAppStatus.bState  = dfuERROR;
 303:dfu.c         ****                 dfuAppStatus.bStatus = errNOTDONE;
 304:dfu.c         ****             }
 305:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 306:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 307:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 308:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 309:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 310:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 311:dfu.c         ****         } else {
 312:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 313:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 314:dfu.c         ****         }
 315:dfu.c         **** 
 316:dfu.c         **** 
 317:dfu.c         ****     } else if (startState == dfuERROR)               {
 318:dfu.c         ****         /* status is in error, awaiting DFU_CLRSTATUS request */
 319:dfu.c         **** 
 320:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 321:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 322:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 323:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 324:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 325:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
 326:dfu.c         ****             /* todo handle any cleanup we need here */
 327:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 328:dfu.c         ****             dfuAppStatus.bStatus = OK;
 329:dfu.c         ****         } else {
 330:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 331:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 332:dfu.c         ****         }
 333:dfu.c         **** 
 334:dfu.c         ****     } else {
 335:dfu.c         ****         /* some kind of error... */
 336:dfu.c         ****         dfuAppStatus.bState  = dfuERROR;
 337:dfu.c         ****         dfuAppStatus.bStatus = errSTALLEDPKT;
 338:dfu.c         ****     }
 339:dfu.c         **** 
 340:dfu.c         ****     if (dfuAppStatus.bStatus == OK) {
 341:dfu.c         ****         return TRUE;
 342:dfu.c         ****     } else {
 343:dfu.c         ****         return FALSE;
 344:dfu.c         ****     }
 345:dfu.c         **** }
 346:dfu.c         **** 
 347:dfu.c         **** void dfuUpdateByReset(void) {
 117              		.loc 1 347 29 is_stmt 1 view -0
 118              		.cfi_startproc
 119              		@ args = 0, pretend = 0, frame = 0
 120              		@ frame_needed = 0, uses_anonymous_args = 0
 348:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 121              		.loc 1 348 5 view .LVU35
 349:dfu.c         ****     userFirmwareLen = 0;
 122              		.loc 1 349 21 is_stmt 0 view .LVU36
 123 0000 0022     		movs	r2, #0
 347:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 124              		.loc 1 347 29 view .LVU37
 125 0002 10B5     		push	{r4, lr}
 126              		.cfi_def_cfa_offset 8
 127              		.cfi_offset 4, -8
 128              		.cfi_offset 14, -4
 348:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 129              		.loc 1 348 8 view .LVU38
 130 0004 0D4B     		ldr	r3, .L7
 131              		.loc 1 349 21 view .LVU39
 132 0006 0E4C     		ldr	r4, .L7+4
 348:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 133              		.loc 1 348 8 view .LVU40
 134 0008 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 135              		.loc 1 349 21 view .LVU41
 136 000a 2260     		str	r2, [r4]
 350:dfu.c         **** 
 351:dfu.c         ****     if (startState == appDETACH) {
 137              		.loc 1 351 8 view .LVU42
 138 000c 0129     		cmp	r1, #1
 348:dfu.c         ****     userFirmwareLen = 0;
 139              		.loc 1 348 8 view .LVU43
 140 000e C8B2     		uxtb	r0, r1
 141              	.LVL0:
 349:dfu.c         **** 
 142              		.loc 1 349 5 is_stmt 1 view .LVU44
 143              		.loc 1 351 5 view .LVU45
 144              		.loc 1 351 8 is_stmt 0 view .LVU46
 145 0010 08D1     		bne	.L5
 352:dfu.c         ****         dfuAppStatus.bState = dfuIDLE;
 146              		.loc 1 352 9 is_stmt 1 view .LVU47
 147              		.loc 1 352 29 is_stmt 0 view .LVU48
 148 0012 0221     		movs	r1, #2
 149 0014 1971     		strb	r1, [r3, #4]
 353:dfu.c         ****         dfuAppStatus.bStatus = OK;
 150              		.loc 1 353 9 is_stmt 1 view .LVU49
 151              		.loc 1 353 30 is_stmt 0 view .LVU50
 152 0016 1A70     		strb	r2, [r3]
 354:dfu.c         **** 
 355:dfu.c         ****         nvicDisableInterrupts();
 153              		.loc 1 355 9 is_stmt 1 view .LVU51
 154 0018 FFF7FEFF 		bl	nvicDisableInterrupts
 155              	.LVL1:
 356:dfu.c         ****         usbEnbISR();
 156              		.loc 1 356 9 view .LVU52
 357:dfu.c         **** 
 358:dfu.c         ****     } else if (startState == appIDLE || startState == dfuIDLE) {
 359:dfu.c         ****         /* do nothing...might be normal usb bus activity */
 360:dfu.c         ****     } else {
 361:dfu.c         ****         /* we reset from the dfu, reset everything and startover,
 362:dfu.c         ****            which is the correct operation if this is an erroneous
 363:dfu.c         ****            event or properly following a MANIFEST */
 364:dfu.c         ****         dfuAppStatus.bState = dfuIDLE;
 365:dfu.c         ****         dfuAppStatus.bStatus = OK;
 366:dfu.c         **** 
 367:dfu.c         ****         systemHardReset();
 368:dfu.c         ****     }
 369:dfu.c         **** }
 157              		.loc 1 369 1 is_stmt 0 view .LVU53
 158 001c BDE81040 		pop	{r4, lr}
 159              		.cfi_remember_state
 160              		.cfi_restore 14
 161              		.cfi_restore 4
 162              		.cfi_def_cfa_offset 0
 356:dfu.c         ****         usbEnbISR();
 163              		.loc 1 356 9 view .LVU54
 164 0020 FFF7FEBF 		b	usbEnbISR
 165              	.LVL2:
 166              	.L5:
 167              		.cfi_restore_state
 358:dfu.c         ****         /* do nothing...might be normal usb bus activity */
 168              		.loc 1 358 12 is_stmt 1 view .LVU55
 358:dfu.c         ****         /* do nothing...might be normal usb bus activity */
 169              		.loc 1 358 15 is_stmt 0 view .LVU56
 170 0024 10F0FD0F 		tst	r0, #253
 171 0028 06D0     		beq	.L4
 364:dfu.c         ****         dfuAppStatus.bStatus = OK;
 172              		.loc 1 364 9 is_stmt 1 view .LVU57
 364:dfu.c         ****         dfuAppStatus.bStatus = OK;
 173              		.loc 1 364 29 is_stmt 0 view .LVU58
 174 002a 0221     		movs	r1, #2
 175 002c 1971     		strb	r1, [r3, #4]
 365:dfu.c         **** 
 176              		.loc 1 365 9 is_stmt 1 view .LVU59
 365:dfu.c         **** 
 177              		.loc 1 365 30 is_stmt 0 view .LVU60
 178 002e 1A70     		strb	r2, [r3]
 367:dfu.c         ****     }
 179              		.loc 1 367 9 is_stmt 1 view .LVU61
 180              		.loc 1 369 1 is_stmt 0 view .LVU62
 181 0030 BDE81040 		pop	{r4, lr}
 182              		.cfi_remember_state
 183              		.cfi_restore 14
 184              		.cfi_restore 4
 185              		.cfi_def_cfa_offset 0
 367:dfu.c         ****     }
 186              		.loc 1 367 9 view .LVU63
 187 0034 FFF7FEBF 		b	systemHardReset
 188              	.LVL3:
 189              	.L4:
 190              		.cfi_restore_state
 191              		.loc 1 369 1 view .LVU64
 192 0038 10BD     		pop	{r4, pc}
 193              	.L8:
 194 003a 00BF     		.align	2
 195              	.L7:
 196 003c 00000000 		.word	.LANCHOR0
 197 0040 00000000 		.word	.LANCHOR1
 198              		.cfi_endproc
 199              	.LFE2:
 201              		.section	.text.dfuUpdateByTimeout,"ax",%progbits
 202              		.align	1
 203              		.global	dfuUpdateByTimeout
 204              		.syntax unified
 205              		.thumb
 206              		.thumb_func
 207              		.fpu softvfp
 209              	dfuUpdateByTimeout:
 210              	.LFB3:
 370:dfu.c         **** 
 371:dfu.c         **** void dfuUpdateByTimeout(void) {
 211              		.loc 1 371 31 is_stmt 1 view -0
 212              		.cfi_startproc
 213              		@ args = 0, pretend = 0, frame = 0
 214              		@ frame_needed = 0, uses_anonymous_args = 0
 215              		@ link register save eliminated.
 372:dfu.c         **** }
 216              		.loc 1 372 1 view .LVU66
 217 0000 7047     		bx	lr
 218              		.cfi_endproc
 219              	.LFE3:
 221              		.section	.text.dfuCopyState,"ax",%progbits
 222              		.align	1
 223              		.global	dfuCopyState
 224              		.syntax unified
 225              		.thumb
 226              		.thumb_func
 227              		.fpu softvfp
 229              	dfuCopyState:
 230              	.LVL4:
 231              	.LFB4:
 373:dfu.c         **** 
 374:dfu.c         **** u8 *dfuCopyState(u16 length) {
 232              		.loc 1 374 30 view -0
 233              		.cfi_startproc
 234              		@ args = 0, pretend = 0, frame = 0
 235              		@ frame_needed = 0, uses_anonymous_args = 0
 236              		@ link register save eliminated.
 375:dfu.c         ****     if (length == 0) {
 237              		.loc 1 375 5 view .LVU68
 238              		.loc 1 375 8 is_stmt 0 view .LVU69
 239 0000 20B9     		cbnz	r0, .L12
 376:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = 1;
 240              		.loc 1 376 9 is_stmt 1 view .LVU70
 241              		.loc 1 376 45 is_stmt 0 view .LVU71
 242 0002 0122     		movs	r2, #1
 243 0004 024B     		ldr	r3, .L13
 244 0006 1B68     		ldr	r3, [r3]
 245 0008 1A82     		strh	r2, [r3, #16]	@ movhi
 377:dfu.c         ****         return NULL;
 246              		.loc 1 377 9 is_stmt 1 view .LVU72
 247              		.loc 1 377 16 is_stmt 0 view .LVU73
 248 000a 7047     		bx	lr
 249              	.L12:
 378:dfu.c         ****     } else {
 379:dfu.c         ****         return (&(dfuAppStatus.bState));
 250              		.loc 1 379 17 view .LVU74
 251 000c 0148     		ldr	r0, .L13+4
 252              	.LVL5:
 380:dfu.c         ****     }
 381:dfu.c         **** }
 253              		.loc 1 381 1 view .LVU75
 254 000e 7047     		bx	lr
 255              	.L14:
 256              		.align	2
 257              	.L13:
 258 0010 00000000 		.word	pInformation
 259 0014 04000000 		.word	.LANCHOR0+4
 260              		.cfi_endproc
 261              	.LFE4:
 263              		.section	.text.dfuCopyStatus,"ax",%progbits
 264              		.align	1
 265              		.global	dfuCopyStatus
 266              		.syntax unified
 267              		.thumb
 268              		.thumb_func
 269              		.fpu softvfp
 271              	dfuCopyStatus:
 272              	.LVL6:
 273              	.LFB5:
 382:dfu.c         **** 
 383:dfu.c         **** u8 *dfuCopyStatus(u16 length) {
 274              		.loc 1 383 31 is_stmt 1 view -0
 275              		.cfi_startproc
 276              		@ args = 0, pretend = 0, frame = 0
 277              		@ frame_needed = 0, uses_anonymous_args = 0
 278              		@ link register save eliminated.
 384:dfu.c         ****     if (length == 0) {
 279              		.loc 1 384 5 view .LVU77
 280              		.loc 1 384 8 is_stmt 0 view .LVU78
 281 0000 20B9     		cbnz	r0, .L17
 385:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = 6;
 282              		.loc 1 385 9 is_stmt 1 view .LVU79
 283              		.loc 1 385 45 is_stmt 0 view .LVU80
 284 0002 0622     		movs	r2, #6
 285 0004 024B     		ldr	r3, .L18
 286 0006 1B68     		ldr	r3, [r3]
 287 0008 1A82     		strh	r2, [r3, #16]	@ movhi
 386:dfu.c         ****         return NULL;
 288              		.loc 1 386 9 is_stmt 1 view .LVU81
 289              		.loc 1 386 16 is_stmt 0 view .LVU82
 290 000a 7047     		bx	lr
 291              	.L17:
 387:dfu.c         ****     } else {
 388:dfu.c         ****         return (u8*)(&dfuAppStatus);
 292              		.loc 1 388 16 view .LVU83
 293 000c 0148     		ldr	r0, .L18+4
 294              	.LVL7:
 389:dfu.c         ****     }
 390:dfu.c         **** }
 295              		.loc 1 390 1 view .LVU84
 296 000e 7047     		bx	lr
 297              	.L19:
 298              		.align	2
 299              	.L18:
 300 0010 00000000 		.word	pInformation
 301 0014 00000000 		.word	.LANCHOR0
 302              		.cfi_endproc
 303              	.LFE5:
 305              		.section	.text.dfuCopyDNLOAD,"ax",%progbits
 306              		.align	1
 307              		.global	dfuCopyDNLOAD
 308              		.syntax unified
 309              		.thumb
 310              		.thumb_func
 311              		.fpu softvfp
 313              	dfuCopyDNLOAD:
 314              	.LVL8:
 315              	.LFB6:
 391:dfu.c         **** 
 392:dfu.c         **** 
 393:dfu.c         **** u8 *dfuCopyDNLOAD(u16 length) {
 316              		.loc 1 393 31 is_stmt 1 view -0
 317              		.cfi_startproc
 318              		@ args = 0, pretend = 0, frame = 0
 319              		@ frame_needed = 0, uses_anonymous_args = 0
 320              		@ link register save eliminated.
 394:dfu.c         ****     if (length == 0) {
 321              		.loc 1 394 5 view .LVU86
 395:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info
 322              		.loc 1 395 59 is_stmt 0 view .LVU87
 323 0000 064B     		ldr	r3, .L23
 324 0002 1A68     		ldr	r2, [r3]
 325              		.loc 1 395 100 view .LVU88
 326 0004 538A     		ldrh	r3, [r2, #18]
 394:dfu.c         ****     if (length == 0) {
 327              		.loc 1 394 8 view .LVU89
 328 0006 28B9     		cbnz	r0, .L21
 329              		.loc 1 395 9 is_stmt 1 view .LVU90
 330              		.loc 1 395 72 is_stmt 0 view .LVU91
 331 0008 D188     		ldrh	r1, [r2, #6]
 332              		.loc 1 395 75 view .LVU92
 333 000a CB1A     		subs	r3, r1, r3
 334              		.loc 1 395 45 view .LVU93
 335 000c 1382     		strh	r3, [r2, #16]	@ movhi
 396:dfu.c         ****         thisBlockLen = pInformation->USBwLengths.w;
 336              		.loc 1 396 9 is_stmt 1 view .LVU94
 337              		.loc 1 396 22 is_stmt 0 view .LVU95
 338 000e 044B     		ldr	r3, .L23+4
 339 0010 1980     		strh	r1, [r3]	@ movhi
 397:dfu.c         ****         return NULL;
 340              		.loc 1 397 9 is_stmt 1 view .LVU96
 341              		.loc 1 397 16 is_stmt 0 view .LVU97
 342 0012 7047     		bx	lr
 343              	.L21:
 398:dfu.c         ****     } else {
 399:dfu.c         ****         return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
 344              		.loc 1 399 9 is_stmt 1 view .LVU98
 345              		.loc 1 399 34 is_stmt 0 view .LVU99
 346 0014 0348     		ldr	r0, .L23+8
 347              	.LVL9:
 348              		.loc 1 399 34 view .LVU100
 349 0016 1844     		add	r0, r0, r3
 400:dfu.c         ****     }
 401:dfu.c         **** }
 350              		.loc 1 401 1 view .LVU101
 351 0018 7047     		bx	lr
 352              	.L24:
 353 001a 00BF     		.align	2
 354              	.L23:
 355 001c 00000000 		.word	pInformation
 356 0020 00000000 		.word	.LANCHOR2
 357 0024 00000000 		.word	.LANCHOR8
 358              		.cfi_endproc
 359              	.LFE6:
 361              		.section	.text.dfuCopyUPLOAD,"ax",%progbits
 362              		.align	1
 363              		.global	dfuCopyUPLOAD
 364              		.syntax unified
 365              		.thumb
 366              		.thumb_func
 367              		.fpu softvfp
 369              	dfuCopyUPLOAD:
 370              	.LVL10:
 371              	.LFB7:
 402:dfu.c         **** 
 403:dfu.c         **** u8 *dfuCopyUPLOAD(u16 length) {
 372              		.loc 1 403 31 is_stmt 1 view -0
 373              		.cfi_startproc
 374              		@ args = 0, pretend = 0, frame = 0
 375              		@ frame_needed = 0, uses_anonymous_args = 0
 376              		@ link register save eliminated.
 404:dfu.c         ****     if (length == 0) {
 377              		.loc 1 404 5 view .LVU103
 405:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
 378              		.loc 1 405 74 is_stmt 0 view .LVU104
 379 0000 074B     		ldr	r3, .L28
 380 0002 1968     		ldr	r1, [r3]
 381              		.loc 1 405 85 view .LVU105
 382 0004 4A8A     		ldrh	r2, [r1, #18]
 404:dfu.c         ****     if (length == 0) {
 383              		.loc 1 404 8 view .LVU106
 384 0006 20B9     		cbnz	r0, .L26
 385              		.loc 1 405 9 is_stmt 1 view .LVU107
 386              		.loc 1 405 60 is_stmt 0 view .LVU108
 387 0008 064B     		ldr	r3, .L28+4
 388 000a 1B88     		ldrh	r3, [r3]
 389 000c 9B1A     		subs	r3, r3, r2
 390              		.loc 1 405 45 view .LVU109
 391 000e 0B82     		strh	r3, [r1, #16]	@ movhi
 406:dfu.c         ****         return NULL;
 392              		.loc 1 406 9 is_stmt 1 view .LVU110
 393              		.loc 1 406 16 is_stmt 0 view .LVU111
 394 0010 7047     		bx	lr
 395              	.L26:
 407:dfu.c         ****     } else {
 408:dfu.c         ****         return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
 396              		.loc 1 408 9 is_stmt 1 view .LVU112
 397              		.loc 1 408 34 is_stmt 0 view .LVU113
 398 0012 054B     		ldr	r3, .L28+8
 399 0014 1868     		ldr	r0, [r3]
 400              	.LVL11:
 401              		.loc 1 408 34 view .LVU114
 402 0016 054B     		ldr	r3, .L28+12
 403 0018 1B68     		ldr	r3, [r3]
 404 001a 1844     		add	r0, r0, r3
 405              		.loc 1 408 52 view .LVU115
 406 001c 1044     		add	r0, r0, r2
 409:dfu.c         ****     }
 410:dfu.c         **** }
 407              		.loc 1 410 1 view .LVU116
 408 001e 7047     		bx	lr
 409              	.L29:
 410              		.align	2
 411              	.L28:
 412 0020 00000000 		.word	pInformation
 413 0024 00000000 		.word	.LANCHOR2
 414 0028 00000000 		.word	.LANCHOR1
 415 002c 00000000 		.word	.LANCHOR3
 416              		.cfi_endproc
 417              	.LFE7:
 419              		.section	.text.dfuCopyBufferToExec,"ax",%progbits
 420              		.align	1
 421              		.global	dfuCopyBufferToExec
 422              		.syntax unified
 423              		.thumb
 424              		.thumb_func
 425              		.fpu softvfp
 427              	dfuCopyBufferToExec:
 428              	.LFB8:
 411:dfu.c         **** 
 412:dfu.c         **** void dfuCopyBufferToExec() {
 429              		.loc 1 412 28 is_stmt 1 view -0
 430              		.cfi_startproc
 431              		@ args = 0, pretend = 0, frame = 0
 432              		@ frame_needed = 0, uses_anonymous_args = 0
 413:dfu.c         ****     int i;
 433              		.loc 1 413 5 view .LVU118
 414:dfu.c         ****     u32 *userSpace;
 434              		.loc 1 414 5 view .LVU119
 415:dfu.c         **** 
 416:dfu.c         **** /* Roger Clark.
 417:dfu.c         ****     Commented out code associated with upload to RAM
 418:dfu.c         **** 
 419:dfu.c         ****     if (userUploadType == DFU_UPLOAD_RAM)
 420:dfu.c         ****     {
 421:dfu.c         ****         userSpace = (u32 *)(USER_CODE_RAM + userFirmwareLen);
 422:dfu.c         ****         // we dont need to handle when thisBlock len is not divisible by 4,
 423:dfu.c         ****         //   since the linker will align everything to 4B anyway
 424:dfu.c         ****         for (i = 0; i < thisBlockLen; i = i + 4) {
 425:dfu.c         ****             *userSpace++ = *(u32 *)(recvBuffer + i);
 426:dfu.c         ****         }
 427:dfu.c         ****     }
 428:dfu.c         ****     else
 429:dfu.c         **** */
 430:dfu.c         ****     {
 431:dfu.c         ****         if (userUploadType == DFU_UPLOAD_FLASH_0X8005000)
 435              		.loc 1 431 9 view .LVU120
 412:dfu.c         ****     int i;
 436              		.loc 1 412 28 is_stmt 0 view .LVU121
 437 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 438              		.cfi_def_cfa_offset 24
 439              		.cfi_offset 4, -24
 440              		.cfi_offset 5, -20
 441              		.cfi_offset 6, -16
 442              		.cfi_offset 7, -12
 443              		.cfi_offset 8, -8
 444              		.cfi_offset 14, -4
 445              		.loc 1 431 28 view .LVU122
 446 0004 134B     		ldr	r3, .L35
 447 0006 144D     		ldr	r5, .L35+4
 448 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 432:dfu.c         ****         {
 433:dfu.c         ****             userSpace = (u32 *)(USER_CODE_FLASH0X8005000 + userFirmwareLen);
 449              		.loc 1 433 58 view .LVU123
 450 000a 2C68     		ldr	r4, [r5]
 431:dfu.c         ****         {
 451              		.loc 1 431 12 view .LVU124
 452 000c 022B     		cmp	r3, #2
 453              		.loc 1 433 58 view .LVU125
 454 000e 04F10064 		add	r4, r4, #134217728
 455              		.loc 1 433 13 is_stmt 1 view .LVU126
 456              		.loc 1 433 58 is_stmt 0 view .LVU127
 457 0012 0CBF     		ite	eq
 458 0014 04F5A044 		addeq	r4, r4, #20480
 459              	.LVL12:
 434:dfu.c         ****         }
 435:dfu.c         ****         else
 436:dfu.c         ****         {
 437:dfu.c         ****             userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);
 460              		.loc 1 437 13 is_stmt 1 view .LVU128
 461              		.loc 1 437 58 is_stmt 0 view .LVU129
 462 0018 04F50054 		addne	r4, r4, #8192
 438:dfu.c         ****         }
 439:dfu.c         **** 
 440:dfu.c         ****         flashErasePage((u32)(userSpace));
 463              		.loc 1 440 9 is_stmt 1 view .LVU130
 464 001c 2046     		mov	r0, r4
 465 001e FFF7FEFF 		bl	flashErasePage
 466              	.LVL13:
 441:dfu.c         **** 
 442:dfu.c         ****         for (i = 0; i < thisBlockLen; i = i + 4) {
 467              		.loc 1 442 9 view .LVU131
 468              		.loc 1 442 16 is_stmt 0 view .LVU132
 469 0022 0026     		movs	r6, #0
 470 0024 DFF83480 		ldr	r8, .L35+8
 471              		.loc 1 442 23 view .LVU133
 472 0028 0D4F     		ldr	r7, .L35+12
 473              	.LVL14:
 474              	.L33:
 475              		.loc 1 442 21 is_stmt 1 discriminator 1 view .LVU134
 476              		.loc 1 442 23 is_stmt 0 discriminator 1 view .LVU135
 477 002a 3B88     		ldrh	r3, [r7]
 478 002c 9BB2     		uxth	r3, r3
 479              		.loc 1 442 9 discriminator 1 view .LVU136
 480 002e B342     		cmp	r3, r6
 481 0030 08DC     		bgt	.L34
 443:dfu.c         ****             flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
 444:dfu.c         ****         }
 445:dfu.c         **** 
 446:dfu.c         ****     }
 447:dfu.c         ****     userFirmwareLen += thisBlockLen;
 482              		.loc 1 447 5 is_stmt 1 view .LVU137
 483 0032 3B88     		ldrh	r3, [r7]
 484              		.loc 1 447 21 is_stmt 0 view .LVU138
 485 0034 2A68     		ldr	r2, [r5]
 486              		.loc 1 447 5 view .LVU139
 487 0036 9BB2     		uxth	r3, r3
 488              		.loc 1 447 21 view .LVU140
 489 0038 1344     		add	r3, r3, r2
 490 003a 2B60     		str	r3, [r5]
 448:dfu.c         **** 
 449:dfu.c         ****     thisBlockLen = 0;
 491              		.loc 1 449 5 is_stmt 1 view .LVU141
 492              		.loc 1 449 18 is_stmt 0 view .LVU142
 493 003c 0023     		movs	r3, #0
 494 003e 3B80     		strh	r3, [r7]	@ movhi
 450:dfu.c         **** }
 495              		.loc 1 450 1 view .LVU143
 496 0040 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 497              	.LVL15:
 498              	.L34:
 443:dfu.c         ****             flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
 499              		.loc 1 443 13 is_stmt 1 discriminator 3 view .LVU144
 443:dfu.c         ****             flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
 500              		.loc 1 443 13 is_stmt 0 discriminator 3 view .LVU145
 501 0044 A019     		adds	r0, r4, r6
 502 0046 58F8041B 		ldr	r1, [r8], #4
 503 004a FFF7FEFF 		bl	flashWriteWord
 504              	.LVL16:
 442:dfu.c         ****             flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
 505              		.loc 1 442 39 is_stmt 1 discriminator 3 view .LVU146
 442:dfu.c         ****             flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
 506              		.loc 1 442 41 is_stmt 0 discriminator 3 view .LVU147
 507 004e 0436     		adds	r6, r6, #4
 508              	.LVL17:
 442:dfu.c         ****             flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
 509              		.loc 1 442 41 discriminator 3 view .LVU148
 510 0050 EBE7     		b	.L33
 511              	.L36:
 512 0052 00BF     		.align	2
 513              	.L35:
 514 0054 00000000 		.word	.LANCHOR5
 515 0058 00000000 		.word	.LANCHOR1
 516 005c 00000000 		.word	.LANCHOR8
 517 0060 00000000 		.word	.LANCHOR2
 518              		.cfi_endproc
 519              	.LFE8:
 521              		.section	.text.dfuUpdateByRequest,"ax",%progbits
 522              		.align	1
 523              		.global	dfuUpdateByRequest
 524              		.syntax unified
 525              		.thumb
 526              		.thumb_func
 527              		.fpu softvfp
 529              	dfuUpdateByRequest:
 530              	.LFB1:
  75:dfu.c         ****     /* were using the global pInformation struct from usb_lib here,
 531              		.loc 1 75 31 is_stmt 1 view -0
 532              		.cfi_startproc
 533              		@ args = 0, pretend = 0, frame = 0
 534              		@ frame_needed = 0, uses_anonymous_args = 0
  78:dfu.c         **** 
 535              		.loc 1 78 5 view .LVU150
  78:dfu.c         **** 
 536              		.loc 1 78 13 is_stmt 0 view .LVU151
 537 0000 0120     		movs	r0, #1
  83:dfu.c         ****     /* often leaner to nest if's then embed a switch/case */
 538              		.loc 1 83 26 view .LVU152
 539 0002 0022     		movs	r2, #0
  78:dfu.c         **** 
 540              		.loc 1 78 13 view .LVU153
 541 0004 7F49     		ldr	r1, .L97
  75:dfu.c         ****     /* were using the global pInformation struct from usb_lib here,
 542              		.loc 1 75 31 view .LVU154
 543 0006 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 544              		.cfi_def_cfa_offset 24
 545              		.cfi_offset 3, -24
 546              		.cfi_offset 4, -20
 547              		.cfi_offset 5, -16
 548              		.cfi_offset 6, -12
 549              		.cfi_offset 7, -8
 550              		.cfi_offset 14, -4
  82:dfu.c         ****     dfuAppStatus.bStatus = OK;
 551              		.loc 1 82 8 view .LVU155
 552 0008 7F4C     		ldr	r4, .L97+4
  78:dfu.c         **** 
 553              		.loc 1 78 13 view .LVU156
 554 000a 0870     		strb	r0, [r1]
  82:dfu.c         ****     dfuAppStatus.bStatus = OK;
 555              		.loc 1 82 5 is_stmt 1 view .LVU157
  82:dfu.c         ****     dfuAppStatus.bStatus = OK;
 556              		.loc 1 82 8 is_stmt 0 view .LVU158
 557 000c 2579     		ldrb	r5, [r4, #4]	@ zero_extendqisi2
  83:dfu.c         ****     /* often leaner to nest if's then embed a switch/case */
 558              		.loc 1 83 26 view .LVU159
 559 000e 2270     		strb	r2, [r4]
  85:dfu.c         ****         /*  device running inside DFU mode */
 560              		.loc 1 85 8 view .LVU160
 561 0010 022D     		cmp	r5, #2
  82:dfu.c         ****     dfuAppStatus.bStatus = OK;
 562              		.loc 1 82 8 view .LVU161
 563 0012 EBB2     		uxtb	r3, r5
 564              	.LVL18:
  83:dfu.c         ****     /* often leaner to nest if's then embed a switch/case */
 565              		.loc 1 83 5 is_stmt 1 view .LVU162
  85:dfu.c         ****         /*  device running inside DFU mode */
 566              		.loc 1 85 5 view .LVU163
  85:dfu.c         ****         /*  device running inside DFU mode */
 567              		.loc 1 85 8 is_stmt 0 view .LVU164
 568 0014 64D1     		bne	.L38
  87:dfu.c         **** 
 569              		.loc 1 87 9 is_stmt 1 view .LVU165
  87:dfu.c         **** 
 570              		.loc 1 87 17 is_stmt 0 view .LVU166
 571 0016 0870     		strb	r0, [r1]
  89:dfu.c         **** 
 572              		.loc 1 89 9 is_stmt 1 view .LVU167
  89:dfu.c         **** 
 573              		.loc 1 89 25 is_stmt 0 view .LVU168
 574 0018 7C49     		ldr	r1, .L97+8
 575 001a 0968     		ldr	r1, [r1]
 576 001c 4878     		ldrb	r0, [r1, #1]	@ zero_extendqisi2
  89:dfu.c         **** 
 577              		.loc 1 89 12 view .LVU169
 578 001e 0128     		cmp	r0, #1
 579 0020 2FD1     		bne	.L39
  91:dfu.c         ****                 userFirmwareLen = 0;
 580              		.loc 1 91 13 is_stmt 1 view .LVU170
  91:dfu.c         ****                 userFirmwareLen = 0;
 581              		.loc 1 91 16 is_stmt 0 view .LVU171
 582 0022 C888     		ldrh	r0, [r1, #6]
 583 0024 0028     		cmp	r0, #0
 584 0026 00F0D080 		beq	.L70
  92:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 585              		.loc 1 92 17 is_stmt 1 view .LVU172
  92:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 586              		.loc 1 92 33 is_stmt 0 view .LVU173
 587 002a 7948     		ldr	r0, .L97+12
  94:dfu.c         ****                 {
 588              		.loc 1 94 36 view .LVU174
 589 002c 097B     		ldrb	r1, [r1, #12]	@ zero_extendqisi2
  92:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 590              		.loc 1 92 33 view .LVU175
 591 002e 0260     		str	r2, [r0]
  93:dfu.c         ****                 switch(pInformation->Current_AlternateSetting)
 592              		.loc 1 93 17 is_stmt 1 view .LVU176
  93:dfu.c         ****                 switch(pInformation->Current_AlternateSetting)
 593              		.loc 1 93 38 is_stmt 0 view .LVU177
 594 0030 0322     		movs	r2, #3
  94:dfu.c         ****                 {
 595              		.loc 1 94 17 view .LVU178
 596 0032 0129     		cmp	r1, #1
  93:dfu.c         ****                 switch(pInformation->Current_AlternateSetting)
 597              		.loc 1 93 38 view .LVU179
 598 0034 2271     		strb	r2, [r4, #4]
  94:dfu.c         ****                 {
 599              		.loc 1 94 17 is_stmt 1 view .LVU180
 600 0036 05D0     		beq	.L41
 601 0038 0229     		cmp	r1, #2
 602 003a 18D0     		beq	.L42
 127:dfu.c         ****                         dfuAppStatus.bStatus = errWRITE;
 603              		.loc 1 127 25 view .LVU181
 127:dfu.c         ****                         dfuAppStatus.bStatus = errWRITE;
 604              		.loc 1 127 46 is_stmt 0 view .LVU182
 605 003c 0A23     		movs	r3, #10
 606              	.LVL19:
 607              	.L86:
 258:dfu.c         ****             dfuAppStatus.bStatus = OK;
 608              		.loc 1 258 34 view .LVU183
 609 003e 2371     		strb	r3, [r4, #4]
 259:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 610              		.loc 1 259 13 is_stmt 1 view .LVU184
 259:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 611              		.loc 1 259 34 is_stmt 0 view .LVU185
 612 0040 2270     		strb	r2, [r4]
 613 0042 0FE0     		b	.L44
 614              	.LVL20:
 615              	.L41:
 105:dfu.c         ****                         userUploadType = DFU_UPLOAD_FLASH_0X8005000;
 616              		.loc 1 105 25 is_stmt 1 view .LVU186
 105:dfu.c         ****                         userUploadType = DFU_UPLOAD_FLASH_0X8005000;
 617              		.loc 1 105 37 is_stmt 0 view .LVU187
 618 0044 7349     		ldr	r1, .L97+16
 619 0046 744A     		ldr	r2, .L97+20
 620 0048 1160     		str	r1, [r2]
 106:dfu.c         **** 
 621              		.loc 1 106 25 is_stmt 1 view .LVU188
 106:dfu.c         **** 
 622              		.loc 1 106 40 is_stmt 0 view .LVU189
 623 004a 744A     		ldr	r2, .L97+24
 624 004c 1370     		strb	r3, [r2]
 109:dfu.c         ****                         flashUnlock();
 625              		.loc 1 109 25 is_stmt 1 view .LVU190
 626 004e FFF7FEFF 		bl	setupFLASH
 627              	.LVL21:
 110:dfu.c         ****                         // Clear lower memory so that we can check on cold boot, whether the last u
 628              		.loc 1 110 25 view .LVU191
 629 0052 FFF7FEFF 		bl	flashUnlock
 630              	.LVL22:
 112:dfu.c         ****                         bkp10Write(RTC_BOOTLOADER_JUST_UPLOADED);
 631              		.loc 1 112 25 view .LVU192
 632 0056 7248     		ldr	r0, .L97+28
 633 0058 FFF7FEFF 		bl	flashErasePage
 634              	.LVL23:
 113:dfu.c         **** 
 635              		.loc 1 113 25 view .LVU193
 636              	.L87:
 122:dfu.c         **** 
 637              		.loc 1 122 25 view .LVU194
 638 005c 44F24D20 		movw	r0, #16973
 639 0060 FFF7FEFF 		bl	bkp10Write
 640              	.LVL24:
 124:dfu.c         ****                     default:
 641              		.loc 1 124 25 view .LVU195
 642              	.L44:
 340:dfu.c         ****         return TRUE;
 643              		.loc 1 340 5 view .LVU196
 340:dfu.c         ****         return TRUE;
 644              		.loc 1 340 21 is_stmt 0 view .LVU197
 645 0064 2078     		ldrb	r0, [r4]	@ zero_extendqisi2
 345:dfu.c         **** 
 646              		.loc 1 345 1 view .LVU198
 647 0066 B0FA80F0 		clz	r0, r0
 648 006a 4009     		lsrs	r0, r0, #5
 649 006c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 650              	.LVL25:
 651              	.L42:
 117:dfu.c         ****                         userAppAddr = USER_CODE_FLASH0X8002000;
 652              		.loc 1 117 25 is_stmt 1 view .LVU199
 117:dfu.c         ****                         userAppAddr = USER_CODE_FLASH0X8002000;
 653              		.loc 1 117 40 is_stmt 0 view .LVU200
 654 006e 6B4B     		ldr	r3, .L97+24
 655              	.LVL26:
 117:dfu.c         ****                         userAppAddr = USER_CODE_FLASH0X8002000;
 656              		.loc 1 117 40 view .LVU201
 657 0070 1A70     		strb	r2, [r3]
 118:dfu.c         ****                         /* make sure the flash is setup properly, unlock it */
 658              		.loc 1 118 25 is_stmt 1 view .LVU202
 118:dfu.c         ****                         /* make sure the flash is setup properly, unlock it */
 659              		.loc 1 118 37 is_stmt 0 view .LVU203
 660 0072 694B     		ldr	r3, .L97+20
 661 0074 6A4A     		ldr	r2, .L97+28
 662 0076 1A60     		str	r2, [r3]
 120:dfu.c         ****                         flashUnlock();
 663              		.loc 1 120 25 is_stmt 1 view .LVU204
 664 0078 FFF7FEFF 		bl	setupFLASH
 665              	.LVL27:
 121:dfu.c         ****                         bkp10Write(RTC_BOOTLOADER_JUST_UPLOADED);
 666              		.loc 1 121 25 view .LVU205
 667 007c FFF7FEFF 		bl	flashUnlock
 668              	.LVL28:
 669 0080 ECE7     		b	.L87
 670              	.LVL29:
 671              	.L39:
 135:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 672              		.loc 1 135 16 view .LVU206
 135:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 673              		.loc 1 135 19 is_stmt 0 view .LVU207
 674 0082 0228     		cmp	r0, #2
 675 0084 23D1     		bne	.L45
 136:dfu.c         ****             /* record length of first block for calculating target
 676              		.loc 1 136 13 is_stmt 1 view .LVU208
 136:dfu.c         ****             /* record length of first block for calculating target
 677              		.loc 1 136 34 is_stmt 0 view .LVU209
 678 0086 0923     		movs	r3, #9
 679              	.LVL30:
 139:dfu.c         ****             thisBlockLen = uploadBlockLen; /* for this first block as well */
 680              		.loc 1 139 55 view .LVU210
 681 0088 CA88     		ldrh	r2, [r1, #6]
 136:dfu.c         ****             /* record length of first block for calculating target
 682              		.loc 1 136 34 view .LVU211
 683 008a 2371     		strb	r3, [r4, #4]
 139:dfu.c         ****             thisBlockLen = uploadBlockLen; /* for this first block as well */
 684              		.loc 1 139 13 is_stmt 1 view .LVU212
 139:dfu.c         ****             thisBlockLen = uploadBlockLen; /* for this first block as well */
 685              		.loc 1 139 28 is_stmt 0 view .LVU213
 686 008c 654B     		ldr	r3, .L97+32
 140:dfu.c         ****             /* calculate where the data should be copied from */
 687              		.loc 1 140 26 view .LVU214
 688 008e 6648     		ldr	r0, .L97+36
 139:dfu.c         ****             thisBlockLen = uploadBlockLen; /* for this first block as well */
 689              		.loc 1 139 28 view .LVU215
 690 0090 1A80     		strh	r2, [r3]	@ movhi
 140:dfu.c         ****             /* calculate where the data should be copied from */
 691              		.loc 1 140 13 is_stmt 1 view .LVU216
 140:dfu.c         ****             /* calculate where the data should be copied from */
 692              		.loc 1 140 26 is_stmt 0 view .LVU217
 693 0092 1A88     		ldrh	r2, [r3]
 694 0094 92B2     		uxth	r2, r2
 695 0096 0280     		strh	r2, [r0]	@ movhi
 142:dfu.c         ****             switch(pInformation->Current_AlternateSetting)
 696              		.loc 1 142 13 is_stmt 1 view .LVU218
 142:dfu.c         ****             switch(pInformation->Current_AlternateSetting)
 697              		.loc 1 142 46 is_stmt 0 view .LVU219
 698 0098 1B88     		ldrh	r3, [r3]
 699 009a 9AB2     		uxth	r2, r3
 142:dfu.c         ****             switch(pInformation->Current_AlternateSetting)
 700              		.loc 1 142 62 view .LVU220
 701 009c 4B88     		ldrh	r3, [r1, #2]
 142:dfu.c         ****             switch(pInformation->Current_AlternateSetting)
 702              		.loc 1 142 46 view .LVU221
 703 009e 5343     		muls	r3, r2, r3
 142:dfu.c         ****             switch(pInformation->Current_AlternateSetting)
 704              		.loc 1 142 29 view .LVU222
 705 00a0 5B4A     		ldr	r2, .L97+12
 706 00a2 1360     		str	r3, [r2]
 143:dfu.c         ****             {
 707              		.loc 1 143 13 is_stmt 1 view .LVU223
 143:dfu.c         ****             {
 708              		.loc 1 143 32 is_stmt 0 view .LVU224
 709 00a4 0B7B     		ldrb	r3, [r1, #12]	@ zero_extendqisi2
 143:dfu.c         ****             {
 710              		.loc 1 143 13 view .LVU225
 711 00a6 012B     		cmp	r3, #1
 712 00a8 06D0     		beq	.L46
 713 00aa 022B     		cmp	r3, #2
 714 00ac 0CD0     		beq	.L47
 162:dfu.c         ****                     dfuAppStatus.bStatus = errWRITE;
 715              		.loc 1 162 21 is_stmt 1 view .LVU226
 162:dfu.c         ****                     dfuAppStatus.bStatus = errWRITE;
 716              		.loc 1 162 42 is_stmt 0 view .LVU227
 717 00ae 0A23     		movs	r3, #10
 718 00b0 2371     		strb	r3, [r4, #4]
 163:dfu.c         ****                     break;
 719              		.loc 1 163 21 is_stmt 1 view .LVU228
 163:dfu.c         ****                     break;
 720              		.loc 1 163 42 is_stmt 0 view .LVU229
 721 00b2 0323     		movs	r3, #3
 722              	.LVL31:
 723              	.L83:
 337:dfu.c         ****     }
 724              		.loc 1 337 30 view .LVU230
 725 00b4 2370     		strb	r3, [r4]
 726 00b6 D5E7     		b	.L44
 727              	.LVL32:
 728              	.L46:
 151:dfu.c         ****                     userAppEnd = getFlashEnd();
 729              		.loc 1 151 21 is_stmt 1 view .LVU231
 151:dfu.c         ****                     userAppEnd = getFlashEnd();
 730              		.loc 1 151 33 is_stmt 0 view .LVU232
 731 00b8 574B     		ldr	r3, .L97+20
 732 00ba 564A     		ldr	r2, .L97+16
 733              	.L82:
 155:dfu.c         ****                     userAppEnd = getFlashEnd();
 734              		.loc 1 155 33 view .LVU233
 735 00bc 1A60     		str	r2, [r3]
 156:dfu.c         ****                     break;
 736              		.loc 1 156 21 is_stmt 1 view .LVU234
 156:dfu.c         ****                     break;
 737              		.loc 1 156 34 is_stmt 0 view .LVU235
 738 00be FFF7FEFF 		bl	getFlashEnd
 739              	.LVL33:
 156:dfu.c         ****                     break;
 740              		.loc 1 156 32 view .LVU236
 741 00c2 5A4B     		ldr	r3, .L97+40
 742 00c4 1860     		str	r0, [r3]
 157:dfu.c         ****                 default:
 743              		.loc 1 157 21 is_stmt 1 view .LVU237
 744 00c6 CDE7     		b	.L44
 745              	.L47:
 155:dfu.c         ****                     userAppEnd = getFlashEnd();
 746              		.loc 1 155 21 view .LVU238
 155:dfu.c         ****                     userAppEnd = getFlashEnd();
 747              		.loc 1 155 33 is_stmt 0 view .LVU239
 748 00c8 534B     		ldr	r3, .L97+20
 749 00ca 554A     		ldr	r2, .L97+28
 750 00cc F6E7     		b	.L82
 751              	.LVL34:
 752              	.L45:
 166:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 753              		.loc 1 166 16 is_stmt 1 view .LVU240
 166:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 754              		.loc 1 166 19 is_stmt 0 view .LVU241
 755 00ce 0628     		cmp	r0, #6
 756 00d0 B5D0     		beq	.L86
 169:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 757              		.loc 1 169 16 is_stmt 1 view .LVU242
 169:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 758              		.loc 1 169 19 is_stmt 0 view .LVU243
 759 00d2 0328     		cmp	r0, #3
 760 00d4 01D1     		bne	.L50
 761              	.LVL35:
 762              	.L85:
 226:dfu.c         ****         } else {
 763              		.loc 1 226 33 view .LVU244
 764 00d6 2371     		strb	r3, [r4, #4]
 765 00d8 C4E7     		b	.L44
 766              	.LVL36:
 767              	.L50:
 171:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 768              		.loc 1 171 16 is_stmt 1 view .LVU245
 171:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 769              		.loc 1 171 19 is_stmt 0 view .LVU246
 770 00da 0528     		cmp	r0, #5
 771              	.L93:
 260:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 772              		.loc 1 260 19 view .LVU247
 773 00dc 31D1     		bne	.L76
 774 00de FAE7     		b	.L85
 775              	.L38:
 178:dfu.c         ****         /* device received block, waiting for DFU_GETSTATUS request */
 776              		.loc 1 178 12 is_stmt 1 view .LVU248
 178:dfu.c         ****         /* device received block, waiting for DFU_GETSTATUS request */
 777              		.loc 1 178 15 is_stmt 0 view .LVU249
 778 00e0 032B     		cmp	r3, #3
 779 00e2 0BD1     		bne	.L52
 181:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 780              		.loc 1 181 9 is_stmt 1 view .LVU250
 181:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 781              		.loc 1 181 25 is_stmt 0 view .LVU251
 782 00e4 494A     		ldr	r2, .L97+8
 783 00e6 1268     		ldr	r2, [r2]
 784 00e8 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 181:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 785              		.loc 1 181 12 view .LVU252
 786 00ea 032A     		cmp	r2, #3
 787 00ec 04D1     		bne	.L53
 210:dfu.c         ****                 dfuCopyBufferToExec();
 788              		.loc 1 210 17 is_stmt 1 view .LVU253
 210:dfu.c         ****                 dfuCopyBufferToExec();
 789              		.loc 1 210 37 is_stmt 0 view .LVU254
 790 00ee 0523     		movs	r3, #5
 791              	.LVL37:
 210:dfu.c         ****                 dfuCopyBufferToExec();
 792              		.loc 1 210 37 view .LVU255
 793 00f0 2371     		strb	r3, [r4, #4]
 211:dfu.c         ****             }
 794              		.loc 1 211 17 is_stmt 1 view .LVU256
 795 00f2 FFF7FEFF 		bl	dfuCopyBufferToExec
 796              	.LVL38:
 797 00f6 B5E7     		b	.L44
 798              	.LVL39:
 799              	.L53:
 214:dfu.c         ****             dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 800              		.loc 1 214 16 view .LVU257
 214:dfu.c         ****             dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 801              		.loc 1 214 19 is_stmt 0 view .LVU258
 802 00f8 052A     		cmp	r2, #5
 803 00fa EFE7     		b	.L93
 804              	.L52:
 221:dfu.c         ****         /* if were actually done writing, goto sync, else stay busy */
 805              		.loc 1 221 12 is_stmt 1 view .LVU259
 221:dfu.c         ****         /* if were actually done writing, goto sync, else stay busy */
 806              		.loc 1 221 15 is_stmt 0 view .LVU260
 807 00fc 042B     		cmp	r3, #4
 808 00fe 08D1     		bne	.L55
 223:dfu.c         ****             dfuAppStatus.bwPollTimeout0 = 0x00;
 809              		.loc 1 223 9 is_stmt 1 view .LVU261
 223:dfu.c         ****             dfuAppStatus.bwPollTimeout0 = 0x00;
 810              		.loc 1 223 28 is_stmt 0 view .LVU262
 811 0100 4B49     		ldr	r1, .L97+44
 812 0102 0878     		ldrb	r0, [r1]	@ zero_extendqisi2
 223:dfu.c         ****             dfuAppStatus.bwPollTimeout0 = 0x00;
 813              		.loc 1 223 12 view .LVU263
 814 0104 0228     		cmp	r0, #2
 224:dfu.c         ****             code_copy_lock = WAIT;
 815              		.loc 1 224 13 is_stmt 1 view .LVU264
 225:dfu.c         ****             dfuAppStatus.bState = dfuDNLOAD_IDLE;
 816              		.loc 1 225 28 is_stmt 0 view .LVU265
 817 0106 01BF     		itttt	eq
 818 0108 0323     		moveq	r3, #3
 819              	.LVL40:
 224:dfu.c         ****             code_copy_lock = WAIT;
 820              		.loc 1 224 41 view .LVU266
 821 010a 6270     		strbeq	r2, [r4, #1]
 225:dfu.c         ****             dfuAppStatus.bState = dfuDNLOAD_IDLE;
 822              		.loc 1 225 13 is_stmt 1 view .LVU267
 225:dfu.c         ****             dfuAppStatus.bState = dfuDNLOAD_IDLE;
 823              		.loc 1 225 28 is_stmt 0 view .LVU268
 824 010c 0B70     		strbeq	r3, [r1]
 226:dfu.c         ****         } else {
 825              		.loc 1 226 13 is_stmt 1 view .LVU269
 226:dfu.c         ****         } else {
 826              		.loc 1 226 33 is_stmt 0 view .LVU270
 827 010e 0523     		moveq	r3, #5
 828 0110 E1E7     		b	.L85
 829              	.LVL41:
 830              	.L55:
 231:dfu.c         ****         /* device is expecting dfu_dnload requests */
 831              		.loc 1 231 12 is_stmt 1 view .LVU271
 231:dfu.c         ****         /* device is expecting dfu_dnload requests */
 832              		.loc 1 231 15 is_stmt 0 view .LVU272
 833 0112 052B     		cmp	r3, #5
 834 0114 19D1     		bne	.L57
 233:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 835              		.loc 1 233 9 is_stmt 1 view .LVU273
 233:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 836              		.loc 1 233 25 is_stmt 0 view .LVU274
 837 0116 3D4B     		ldr	r3, .L97+8
 838              	.LVL42:
 233:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 839              		.loc 1 233 25 view .LVU275
 840 0118 1A68     		ldr	r2, [r3]
 841 011a 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 233:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 842              		.loc 1 233 12 view .LVU276
 843 011c 012B     		cmp	r3, #1
 844 011e 08D1     		bne	.L58
 234:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 845              		.loc 1 234 13 is_stmt 1 view .LVU277
 234:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 846              		.loc 1 234 16 is_stmt 0 view .LVU278
 847 0120 D388     		ldrh	r3, [r2, #6]
 848 0122 0BB1     		cbz	r3, .L59
 235:dfu.c         ****             } else {
 849              		.loc 1 235 17 is_stmt 1 view .LVU279
 235:dfu.c         ****             } else {
 850              		.loc 1 235 38 is_stmt 0 view .LVU280
 851 0124 0323     		movs	r3, #3
 852 0126 D6E7     		b	.L85
 853              	.L59:
 238:dfu.c         **** 
 854              		.loc 1 238 17 is_stmt 1 view .LVU281
 238:dfu.c         **** 
 855              		.loc 1 238 38 is_stmt 0 view .LVU282
 856 0128 0623     		movs	r3, #6
 857 012a 2371     		strb	r3, [r4, #4]
 241:dfu.c         ****             }
 858              		.loc 1 241 17 is_stmt 1 view .LVU283
 859 012c FFF7FEFF 		bl	flashLock
 860              	.LVL43:
 861 0130 98E7     		b	.L44
 862              	.L58:
 243:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 863              		.loc 1 243 16 view .LVU284
 243:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 864              		.loc 1 243 19 is_stmt 0 view .LVU285
 865 0132 062B     		cmp	r3, #6
 866 0134 01D1     		bne	.L60
 867              	.LVL44:
 868              	.L96:
 306:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 869              		.loc 1 306 13 is_stmt 1 view .LVU286
 306:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 870              		.loc 1 306 34 is_stmt 0 view .LVU287
 871 0136 0223     		movs	r3, #2
 872 0138 CDE7     		b	.L85
 873              	.LVL45:
 874              	.L60:
 245:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 875              		.loc 1 245 16 is_stmt 1 view .LVU288
 245:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 876              		.loc 1 245 19 is_stmt 0 view .LVU289
 877 013a 032B     		cmp	r3, #3
 878 013c FBD0     		beq	.L96
 247:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 879              		.loc 1 247 16 is_stmt 1 view .LVU290
 247:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 880              		.loc 1 247 19 is_stmt 0 view .LVU291
 881 013e 052B     		cmp	r3, #5
 882 0140 F9D0     		beq	.L96
 883              	.L76:
 336:dfu.c         ****         dfuAppStatus.bStatus = errSTALLEDPKT;
 884              		.loc 1 336 9 is_stmt 1 view .LVU292
 336:dfu.c         ****         dfuAppStatus.bStatus = errSTALLEDPKT;
 885              		.loc 1 336 30 is_stmt 0 view .LVU293
 886 0142 0A23     		movs	r3, #10
 887 0144 2371     		strb	r3, [r4, #4]
 337:dfu.c         ****     }
 888              		.loc 1 337 9 is_stmt 1 view .LVU294
 337:dfu.c         ****     }
 889              		.loc 1 337 30 is_stmt 0 view .LVU295
 890 0146 0F23     		movs	r3, #15
 891 0148 B4E7     		b	.L83
 892              	.LVL46:
 893              	.L57:
 254:dfu.c         ****         /* device has received last block, waiting DFU_GETSTATUS request */
 894              		.loc 1 254 12 is_stmt 1 view .LVU296
 254:dfu.c         ****         /* device has received last block, waiting DFU_GETSTATUS request */
 895              		.loc 1 254 15 is_stmt 0 view .LVU297
 896 014a 062B     		cmp	r3, #6
 897 014c 08D1     		bne	.L63
 257:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 898              		.loc 1 257 9 is_stmt 1 view .LVU298
 257:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 899              		.loc 1 257 25 is_stmt 0 view .LVU299
 900 014e 2F49     		ldr	r1, .L97+8
 901 0150 0968     		ldr	r1, [r1]
 902 0152 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 257:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 903              		.loc 1 257 12 view .LVU300
 904 0154 0329     		cmp	r1, #3
 905 0156 01D1     		bne	.L64
 906              	.L88:
 258:dfu.c         ****             dfuAppStatus.bStatus = OK;
 907              		.loc 1 258 13 is_stmt 1 view .LVU301
 258:dfu.c         ****             dfuAppStatus.bStatus = OK;
 908              		.loc 1 258 34 is_stmt 0 view .LVU302
 909 0158 0823     		movs	r3, #8
 910              	.LVL47:
 258:dfu.c         ****             dfuAppStatus.bStatus = OK;
 911              		.loc 1 258 34 view .LVU303
 912 015a 70E7     		b	.L86
 913              	.LVL48:
 914              	.L64:
 260:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 915              		.loc 1 260 16 is_stmt 1 view .LVU304
 260:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 916              		.loc 1 260 19 is_stmt 0 view .LVU305
 917 015c 0529     		cmp	r1, #5
 918 015e BDE7     		b	.L93
 919              	.L63:
 267:dfu.c         ****         /* device is in manifestation phase */
 920              		.loc 1 267 12 is_stmt 1 view .LVU306
 267:dfu.c         ****         /* device is in manifestation phase */
 921              		.loc 1 267 15 is_stmt 0 view .LVU307
 922 0160 072B     		cmp	r3, #7
 923 0162 F9D0     		beq	.L88
 274:dfu.c         ****         /* device has programmed new firmware but needs external
 924              		.loc 1 274 12 is_stmt 1 view .LVU308
 274:dfu.c         ****         /* device has programmed new firmware but needs external
 925              		.loc 1 274 15 is_stmt 0 view .LVU309
 926 0164 082B     		cmp	r3, #8
 927 0166 B6D0     		beq	.L85
 281:dfu.c         ****         /* device expecting further dfu_upload requests */
 928              		.loc 1 281 12 is_stmt 1 view .LVU310
 281:dfu.c         ****         /* device expecting further dfu_upload requests */
 929              		.loc 1 281 15 is_stmt 0 view .LVU311
 930 0168 092B     		cmp	r3, #9
 931 016a 39D1     		bne	.L68
 284:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 932              		.loc 1 284 9 is_stmt 1 view .LVU312
 284:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 933              		.loc 1 284 25 is_stmt 0 view .LVU313
 934 016c 274B     		ldr	r3, .L97+8
 935              	.LVL49:
 284:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 936              		.loc 1 284 25 view .LVU314
 937 016e 1868     		ldr	r0, [r3]
 938 0170 4378     		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 284:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 939              		.loc 1 284 12 view .LVU315
 940 0172 022B     		cmp	r3, #2
 941 0174 2DD1     		bne	.L69
 285:dfu.c         ****                 /* check that this is not the last possible block */
 942              		.loc 1 285 13 is_stmt 1 view .LVU316
 285:dfu.c         ****                 /* check that this is not the last possible block */
 943              		.loc 1 285 42 is_stmt 0 view .LVU317
 944 0176 C588     		ldrh	r5, [r0, #6]
 945              	.LVL50:
 285:dfu.c         ****                 /* check that this is not the last possible block */
 946              		.loc 1 285 16 view .LVU318
 947 0178 3DB3     		cbz	r5, .L70
 287:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 948              		.loc 1 287 17 is_stmt 1 view .LVU319
 287:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 949              		.loc 1 287 50 is_stmt 0 view .LVU320
 950 017a 2A49     		ldr	r1, .L97+32
 288:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 951              		.loc 1 288 33 view .LVU321
 952 017c 264E     		ldr	r6, .L97+20
 287:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 953              		.loc 1 287 50 view .LVU322
 954 017e 0B88     		ldrh	r3, [r1]
 288:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 955              		.loc 1 288 68 view .LVU323
 956 0180 2A4F     		ldr	r7, .L97+40
 287:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 957              		.loc 1 287 50 view .LVU324
 958 0182 9AB2     		uxth	r2, r3
 287:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 959              		.loc 1 287 66 view .LVU325
 960 0184 4388     		ldrh	r3, [r0, #2]
 287:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 961              		.loc 1 287 33 view .LVU326
 962 0186 2248     		ldr	r0, .L97+12
 287:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 963              		.loc 1 287 50 view .LVU327
 964 0188 5343     		muls	r3, r2, r3
 287:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 965              		.loc 1 287 33 view .LVU328
 966 018a 0360     		str	r3, [r0]
 288:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 967              		.loc 1 288 17 is_stmt 1 view .LVU329
 288:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 968              		.loc 1 288 33 is_stmt 0 view .LVU330
 969 018c 3368     		ldr	r3, [r6]
 970 018e D0F800E0 		ldr	lr, [r0]
 288:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 971              		.loc 1 288 51 view .LVU331
 972 0192 0A88     		ldrh	r2, [r1]
 288:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 973              		.loc 1 288 33 view .LVU332
 974 0194 7344     		add	r3, r3, lr
 288:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 975              		.loc 1 288 51 view .LVU333
 976 0196 92B2     		uxth	r2, r2
 288:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 977              		.loc 1 288 68 view .LVU334
 978 0198 D7F800C0 		ldr	ip, [r7]
 288:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 979              		.loc 1 288 51 view .LVU335
 980 019c 1344     		add	r3, r3, r2
 288:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 981              		.loc 1 288 20 view .LVU336
 982 019e 6345     		cmp	r3, ip
 983 01a0 214A     		ldr	r2, .L97+36
 984 01a2 04D8     		bhi	.L71
 289:dfu.c         ****                     dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 985              		.loc 1 289 21 is_stmt 1 view .LVU337
 289:dfu.c         ****                     dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 986              		.loc 1 289 34 is_stmt 0 view .LVU338
 987 01a4 0B88     		ldrh	r3, [r1]
 988 01a6 9BB2     		uxth	r3, r3
 989 01a8 1380     		strh	r3, [r2]	@ movhi
 290:dfu.c         ****                 } else {
 990              		.loc 1 290 21 is_stmt 1 view .LVU339
 991              	.L95:
 310:dfu.c         ****         } else {
 992              		.loc 1 310 13 view .LVU340
 310:dfu.c         ****         } else {
 993              		.loc 1 310 34 is_stmt 0 view .LVU341
 994 01aa 0923     		movs	r3, #9
 995 01ac 93E7     		b	.L85
 996              	.L71:
 294:dfu.c         ****                     /* check for overflow due to USBwValue out of range */
 997              		.loc 1 294 21 is_stmt 1 view .LVU342
 294:dfu.c         ****                     /* check for overflow due to USBwValue out of range */
 998              		.loc 1 294 47 is_stmt 0 view .LVU343
 999 01ae 3B68     		ldr	r3, [r7]
 1000 01b0 3168     		ldr	r1, [r6]
 294:dfu.c         ****                     /* check for overflow due to USBwValue out of range */
 1001              		.loc 1 294 61 view .LVU344
 1002 01b2 0068     		ldr	r0, [r0]
 1003 01b4 0144     		add	r1, r1, r0
 1004 01b6 5B1A     		subs	r3, r3, r1
 1005 01b8 9BB2     		uxth	r3, r3
 294:dfu.c         ****                     /* check for overflow due to USBwValue out of range */
 1006              		.loc 1 294 34 view .LVU345
 1007 01ba 1380     		strh	r3, [r2]	@ movhi
 296:dfu.c         ****                         thisBlockLen = 0;
 1008              		.loc 1 296 21 is_stmt 1 view .LVU346
 296:dfu.c         ****                         thisBlockLen = 0;
 1009              		.loc 1 296 38 is_stmt 0 view .LVU347
 1010 01bc 1388     		ldrh	r3, [r2]
 1011 01be 9BB2     		uxth	r3, r3
 296:dfu.c         ****                         thisBlockLen = 0;
 1012              		.loc 1 296 24 view .LVU348
 1013 01c0 9D42     		cmp	r5, r3
 1014 01c2 B8D8     		bhi	.L96
 297:dfu.c         ****                     }
 1015              		.loc 1 297 25 is_stmt 1 view .LVU349
 297:dfu.c         ****                     }
 1016              		.loc 1 297 38 is_stmt 0 view .LVU350
 1017 01c4 0023     		movs	r3, #0
 1018 01c6 1380     		strh	r3, [r2]	@ movhi
 299:dfu.c         ****                 }
 1019              		.loc 1 299 21 is_stmt 1 view .LVU351
 1020 01c8 B5E7     		b	.L96
 1021              	.L70:
 302:dfu.c         ****                 dfuAppStatus.bStatus = errNOTDONE;
 1022              		.loc 1 302 17 view .LVU352
 302:dfu.c         ****                 dfuAppStatus.bStatus = errNOTDONE;
 1023              		.loc 1 302 38 is_stmt 0 view .LVU353
 1024 01ca 0A23     		movs	r3, #10
 1025 01cc 2371     		strb	r3, [r4, #4]
 303:dfu.c         ****             }
 1026              		.loc 1 303 17 is_stmt 1 view .LVU354
 303:dfu.c         ****             }
 1027              		.loc 1 303 38 is_stmt 0 view .LVU355
 1028 01ce 0923     		movs	r3, #9
 1029 01d0 70E7     		b	.L83
 1030              	.LVL51:
 1031              	.L69:
 305:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 1032              		.loc 1 305 16 is_stmt 1 view .LVU356
 305:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 1033              		.loc 1 305 19 is_stmt 0 view .LVU357
 1034 01d2 062B     		cmp	r3, #6
 1035 01d4 AFD0     		beq	.L96
 307:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 1036              		.loc 1 307 16 is_stmt 1 view .LVU358
 307:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 1037              		.loc 1 307 19 is_stmt 0 view .LVU359
 1038 01d6 032B     		cmp	r3, #3
 1039 01d8 E7D0     		beq	.L95
 309:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 1040              		.loc 1 309 16 is_stmt 1 view .LVU360
 309:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 1041              		.loc 1 309 19 is_stmt 0 view .LVU361
 1042 01da 052B     		cmp	r3, #5
 1043 01dc B1D1     		bne	.L76
 1044 01de E4E7     		b	.L95
 1045              	.LVL52:
 1046              	.L68:
 317:dfu.c         ****         /* status is in error, awaiting DFU_CLRSTATUS request */
 1047              		.loc 1 317 12 is_stmt 1 view .LVU362
 317:dfu.c         ****         /* status is in error, awaiting DFU_CLRSTATUS request */
 1048              		.loc 1 317 15 is_stmt 0 view .LVU363
 1049 01e0 0A2B     		cmp	r3, #10
 1050 01e2 AED1     		bne	.L76
 320:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 1051              		.loc 1 320 9 is_stmt 1 view .LVU364
 320:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 1052              		.loc 1 320 25 is_stmt 0 view .LVU365
 1053 01e4 094B     		ldr	r3, .L97+8
 1054              	.LVL53:
 320:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 1055              		.loc 1 320 25 view .LVU366
 1056 01e6 1B68     		ldr	r3, [r3]
 1057 01e8 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 320:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 1058              		.loc 1 320 12 view .LVU367
 1059 01ea 032B     		cmp	r3, #3
 1060 01ec 01D1     		bne	.L77
 1061              	.L91:
 322:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 1062              		.loc 1 322 13 is_stmt 1 view .LVU368
 322:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 1063              		.loc 1 322 34 is_stmt 0 view .LVU369
 1064 01ee 0A23     		movs	r3, #10
 1065 01f0 71E7     		b	.L85
 1066              	.L77:
 323:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 1067              		.loc 1 323 16 is_stmt 1 view .LVU370
 323:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 1068              		.loc 1 323 19 is_stmt 0 view .LVU371
 1069 01f2 052B     		cmp	r3, #5
 1070 01f4 FBD0     		beq	.L91
 325:dfu.c         ****             /* todo handle any cleanup we need here */
 1071              		.loc 1 325 16 is_stmt 1 view .LVU372
 325:dfu.c         ****             /* todo handle any cleanup we need here */
 1072              		.loc 1 325 19 is_stmt 0 view .LVU373
 1073 01f6 042B     		cmp	r3, #4
 1074 01f8 A3D1     		bne	.L76
 327:dfu.c         ****             dfuAppStatus.bStatus = OK;
 1075              		.loc 1 327 13 is_stmt 1 view .LVU374
 327:dfu.c         ****             dfuAppStatus.bStatus = OK;
 1076              		.loc 1 327 34 is_stmt 0 view .LVU375
 1077 01fa 0223     		movs	r3, #2
 1078 01fc 2371     		strb	r3, [r4, #4]
 328:dfu.c         ****         } else {
 1079              		.loc 1 328 13 is_stmt 1 view .LVU376
 328:dfu.c         ****         } else {
 1080              		.loc 1 328 34 is_stmt 0 view .LVU377
 1081 01fe 0023     		movs	r3, #0
 1082 0200 58E7     		b	.L83
 1083              	.L98:
 1084 0202 00BF     		.align	2
 1085              	.L97:
 1086 0204 00000000 		.word	.LANCHOR7
 1087 0208 00000000 		.word	.LANCHOR0
 1088 020c 00000000 		.word	pInformation
 1089 0210 00000000 		.word	.LANCHOR1
 1090 0214 00500008 		.word	134238208
 1091 0218 00000000 		.word	.LANCHOR3
 1092 021c 00000000 		.word	.LANCHOR5
 1093 0220 00200008 		.word	134225920
 1094 0224 00000000 		.word	.LANCHOR9
 1095 0228 00000000 		.word	.LANCHOR2
 1096 022c 00000000 		.word	.LANCHOR4
 1097 0230 00000000 		.word	.LANCHOR6
 1098              		.cfi_endproc
 1099              	.LFE1:
 1101              		.section	.text.dfuGetState,"ax",%progbits
 1102              		.align	1
 1103              		.global	dfuGetState
 1104              		.syntax unified
 1105              		.thumb
 1106              		.thumb_func
 1107              		.fpu softvfp
 1109              	dfuGetState:
 1110              	.LFB9:
 451:dfu.c         **** 
 452:dfu.c         **** u8 dfuGetState(void) {
 1111              		.loc 1 452 22 is_stmt 1 view -0
 1112              		.cfi_startproc
 1113              		@ args = 0, pretend = 0, frame = 0
 1114              		@ frame_needed = 0, uses_anonymous_args = 0
 1115              		@ link register save eliminated.
 453:dfu.c         ****     return dfuAppStatus.bState;
 1116              		.loc 1 453 5 view .LVU379
 1117              		.loc 1 453 24 is_stmt 0 view .LVU380
 1118 0000 014B     		ldr	r3, .L100
 1119 0002 1879     		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 454:dfu.c         **** }
 1120              		.loc 1 454 1 view .LVU381
 1121 0004 7047     		bx	lr
 1122              	.L101:
 1123 0006 00BF     		.align	2
 1124              	.L100:
 1125 0008 00000000 		.word	.LANCHOR0
 1126              		.cfi_endproc
 1127              	.LFE9:
 1129              		.section	.text.dfuSetState,"ax",%progbits
 1130              		.align	1
 1131              		.global	dfuSetState
 1132              		.syntax unified
 1133              		.thumb
 1134              		.thumb_func
 1135              		.fpu softvfp
 1137              	dfuSetState:
 1138              	.LVL54:
 1139              	.LFB10:
 455:dfu.c         **** 
 456:dfu.c         **** void dfuSetState(u8 newState) {
 1140              		.loc 1 456 31 is_stmt 1 view -0
 1141              		.cfi_startproc
 1142              		@ args = 0, pretend = 0, frame = 0
 1143              		@ frame_needed = 0, uses_anonymous_args = 0
 1144              		@ link register save eliminated.
 457:dfu.c         ****     dfuAppStatus.bState = newState;
 1145              		.loc 1 457 5 view .LVU383
 1146              		.loc 1 457 25 is_stmt 0 view .LVU384
 1147 0000 014B     		ldr	r3, .L103
 1148 0002 1871     		strb	r0, [r3, #4]
 458:dfu.c         **** }
 1149              		.loc 1 458 1 view .LVU385
 1150 0004 7047     		bx	lr
 1151              	.L104:
 1152 0006 00BF     		.align	2
 1153              	.L103:
 1154 0008 00000000 		.word	.LANCHOR0
 1155              		.cfi_endproc
 1156              	.LFE10:
 1158              		.section	.text.dfuUploadStarted,"ax",%progbits
 1159              		.align	1
 1160              		.global	dfuUploadStarted
 1161              		.syntax unified
 1162              		.thumb
 1163              		.thumb_func
 1164              		.fpu softvfp
 1166              	dfuUploadStarted:
 1167              	.LFB11:
 459:dfu.c         **** 
 460:dfu.c         **** bool dfuUploadStarted() {
 1168              		.loc 1 460 25 is_stmt 1 view -0
 1169              		.cfi_startproc
 1170              		@ args = 0, pretend = 0, frame = 0
 1171              		@ frame_needed = 0, uses_anonymous_args = 0
 1172              		@ link register save eliminated.
 461:dfu.c         ****     return dfuBusy;
 1173              		.loc 1 461 5 view .LVU387
 1174              		.loc 1 461 12 is_stmt 0 view .LVU388
 1175 0000 014B     		ldr	r3, .L106
 1176 0002 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 462:dfu.c         **** }
 1177              		.loc 1 462 1 view .LVU389
 1178 0004 7047     		bx	lr
 1179              	.L107:
 1180 0006 00BF     		.align	2
 1181              	.L106:
 1182 0008 00000000 		.word	.LANCHOR7
 1183              		.cfi_endproc
 1184              	.LFE11:
 1186              		.section	.text.dfuFinishUpload,"ax",%progbits
 1187              		.align	1
 1188              		.global	dfuFinishUpload
 1189              		.syntax unified
 1190              		.thumb
 1191              		.thumb_func
 1192              		.fpu softvfp
 1194              	dfuFinishUpload:
 1195              	.LFB12:
 463:dfu.c         **** 
 464:dfu.c         **** void dfuFinishUpload() {
 1196              		.loc 1 464 24 is_stmt 1 view -0
 1197              		.cfi_startproc
 1198              		@ Volatile: function does not return.
 1199              		@ args = 0, pretend = 0, frame = 0
 1200              		@ frame_needed = 0, uses_anonymous_args = 0
 1201              		@ link register save eliminated.
 1202              	.L109:
 465:dfu.c         ****     while (1)
 1203              		.loc 1 465 5 discriminator 1 view .LVU391
 466:dfu.c         ****     {
 467:dfu.c         ****         __asm("nop");
 1204              		.loc 1 467 9 discriminator 1 view .LVU392
 1205              		.syntax unified
 1206              	@ 467 "dfu.c" 1
 1207 0000 00BF     		nop
 1208              	@ 0 "" 2
 465:dfu.c         ****     while (1)
 1209              		.loc 1 465 11 discriminator 1 view .LVU393
 1210              		.thumb
 1211              		.syntax unified
 1212 0002 FDE7     		b	.L109
 1213              		.cfi_endproc
 1214              	.LFE12:
 1216              		.global	code_copy_lock
 1217              		.global	dfuBusy
 1218              		.global	userUploadType
 1219              		.section	.bss.code_copy_lock,"aw",%nobits
 1220              		.set	.LANCHOR6,. + 0
 1223              	code_copy_lock:
 1224 0000 00       		.space	1
 1225              		.section	.bss.dfuAppStatus,"aw",%nobits
 1226              		.set	.LANCHOR0,. + 0
 1229              	dfuAppStatus:
 1230 0000 00000000 		.space	6
 1230      0000
 1231              		.section	.bss.dfuBusy,"aw",%nobits
 1232              		.set	.LANCHOR7,. + 0
 1235              	dfuBusy:
 1236 0000 00       		.space	1
 1237              		.section	.bss.recvBuffer,"aw",%nobits
 1238              		.align	2
 1239              		.set	.LANCHOR8,. + 0
 1242              	recvBuffer:
 1243 0000 00000000 		.space	2048
 1243      00000000 
 1243      00000000 
 1243      00000000 
 1243      00000000 
 1244              		.section	.bss.thisBlockLen,"aw",%nobits
 1245              		.align	1
 1246              		.set	.LANCHOR2,. + 0
 1249              	thisBlockLen:
 1250 0000 0000     		.space	2
 1251              		.section	.bss.uploadBlockLen,"aw",%nobits
 1252              		.align	1
 1253              		.set	.LANCHOR9,. + 0
 1256              	uploadBlockLen:
 1257 0000 0000     		.space	2
 1258              		.section	.bss.userFirmwareLen,"aw",%nobits
 1259              		.align	2
 1260              		.set	.LANCHOR1,. + 0
 1263              	userFirmwareLen:
 1264 0000 00000000 		.space	4
 1265              		.section	.bss.userUploadType,"aw",%nobits
 1266              		.set	.LANCHOR5,. + 0
 1269              	userUploadType:
 1270 0000 00       		.space	1
 1271              		.section	.data.userAppAddr,"aw"
 1272              		.align	2
 1273              		.set	.LANCHOR3,. + 0
 1276              	userAppAddr:
 1277 0000 000C0020 		.word	536873984
 1278              		.section	.data.userAppEnd,"aw"
 1279              		.align	2
 1280              		.set	.LANCHOR4,. + 0
 1283              	userAppEnd:
 1284 0000 00500020 		.word	536891392
 1285              		.text
 1286              	.Letext0:
 1287              		.file 2 "./stm32_lib/stm32f10x_type.h"
 1288              		.file 3 "./usb_lib/usb_core.h"
 1289              		.file 4 "dfu.h"
 1290              		.file 5 "./usb_lib/usb_init.h"
 1291              		.file 6 "hardware.h"
 1292              		.file 7 "usb.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 dfu.c
D:\QMK_MSYS\tmp\ccwyr4bu.s:16     .text.dfuInit:0000000000000000 $t
D:\QMK_MSYS\tmp\ccwyr4bu.s:24     .text.dfuInit:0000000000000000 dfuInit
D:\QMK_MSYS\tmp\ccwyr4bu.s:95     .text.dfuInit:0000000000000038 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:108    .text.dfuUpdateByReset:0000000000000000 $t
D:\QMK_MSYS\tmp\ccwyr4bu.s:115    .text.dfuUpdateByReset:0000000000000000 dfuUpdateByReset
D:\QMK_MSYS\tmp\ccwyr4bu.s:196    .text.dfuUpdateByReset:000000000000003c $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:202    .text.dfuUpdateByTimeout:0000000000000000 $t
D:\QMK_MSYS\tmp\ccwyr4bu.s:209    .text.dfuUpdateByTimeout:0000000000000000 dfuUpdateByTimeout
D:\QMK_MSYS\tmp\ccwyr4bu.s:222    .text.dfuCopyState:0000000000000000 $t
D:\QMK_MSYS\tmp\ccwyr4bu.s:229    .text.dfuCopyState:0000000000000000 dfuCopyState
D:\QMK_MSYS\tmp\ccwyr4bu.s:258    .text.dfuCopyState:0000000000000010 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:264    .text.dfuCopyStatus:0000000000000000 $t
D:\QMK_MSYS\tmp\ccwyr4bu.s:271    .text.dfuCopyStatus:0000000000000000 dfuCopyStatus
D:\QMK_MSYS\tmp\ccwyr4bu.s:300    .text.dfuCopyStatus:0000000000000010 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:306    .text.dfuCopyDNLOAD:0000000000000000 $t
D:\QMK_MSYS\tmp\ccwyr4bu.s:313    .text.dfuCopyDNLOAD:0000000000000000 dfuCopyDNLOAD
D:\QMK_MSYS\tmp\ccwyr4bu.s:355    .text.dfuCopyDNLOAD:000000000000001c $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:362    .text.dfuCopyUPLOAD:0000000000000000 $t
D:\QMK_MSYS\tmp\ccwyr4bu.s:369    .text.dfuCopyUPLOAD:0000000000000000 dfuCopyUPLOAD
D:\QMK_MSYS\tmp\ccwyr4bu.s:412    .text.dfuCopyUPLOAD:0000000000000020 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:420    .text.dfuCopyBufferToExec:0000000000000000 $t
D:\QMK_MSYS\tmp\ccwyr4bu.s:427    .text.dfuCopyBufferToExec:0000000000000000 dfuCopyBufferToExec
D:\QMK_MSYS\tmp\ccwyr4bu.s:514    .text.dfuCopyBufferToExec:0000000000000054 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:522    .text.dfuUpdateByRequest:0000000000000000 $t
D:\QMK_MSYS\tmp\ccwyr4bu.s:529    .text.dfuUpdateByRequest:0000000000000000 dfuUpdateByRequest
D:\QMK_MSYS\tmp\ccwyr4bu.s:1086   .text.dfuUpdateByRequest:0000000000000204 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1102   .text.dfuGetState:0000000000000000 $t
D:\QMK_MSYS\tmp\ccwyr4bu.s:1109   .text.dfuGetState:0000000000000000 dfuGetState
D:\QMK_MSYS\tmp\ccwyr4bu.s:1125   .text.dfuGetState:0000000000000008 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1130   .text.dfuSetState:0000000000000000 $t
D:\QMK_MSYS\tmp\ccwyr4bu.s:1137   .text.dfuSetState:0000000000000000 dfuSetState
D:\QMK_MSYS\tmp\ccwyr4bu.s:1154   .text.dfuSetState:0000000000000008 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1159   .text.dfuUploadStarted:0000000000000000 $t
D:\QMK_MSYS\tmp\ccwyr4bu.s:1166   .text.dfuUploadStarted:0000000000000000 dfuUploadStarted
D:\QMK_MSYS\tmp\ccwyr4bu.s:1182   .text.dfuUploadStarted:0000000000000008 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1187   .text.dfuFinishUpload:0000000000000000 $t
D:\QMK_MSYS\tmp\ccwyr4bu.s:1194   .text.dfuFinishUpload:0000000000000000 dfuFinishUpload
D:\QMK_MSYS\tmp\ccwyr4bu.s:1223   .bss.code_copy_lock:0000000000000000 code_copy_lock
D:\QMK_MSYS\tmp\ccwyr4bu.s:1235   .bss.dfuBusy:0000000000000000 dfuBusy
D:\QMK_MSYS\tmp\ccwyr4bu.s:1269   .bss.userUploadType:0000000000000000 userUploadType
D:\QMK_MSYS\tmp\ccwyr4bu.s:1224   .bss.code_copy_lock:0000000000000000 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1229   .bss.dfuAppStatus:0000000000000000 dfuAppStatus
D:\QMK_MSYS\tmp\ccwyr4bu.s:1230   .bss.dfuAppStatus:0000000000000000 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1236   .bss.dfuBusy:0000000000000000 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1238   .bss.recvBuffer:0000000000000000 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1242   .bss.recvBuffer:0000000000000000 recvBuffer
D:\QMK_MSYS\tmp\ccwyr4bu.s:1245   .bss.thisBlockLen:0000000000000000 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1249   .bss.thisBlockLen:0000000000000000 thisBlockLen
D:\QMK_MSYS\tmp\ccwyr4bu.s:1252   .bss.uploadBlockLen:0000000000000000 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1256   .bss.uploadBlockLen:0000000000000000 uploadBlockLen
D:\QMK_MSYS\tmp\ccwyr4bu.s:1259   .bss.userFirmwareLen:0000000000000000 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1263   .bss.userFirmwareLen:0000000000000000 userFirmwareLen
D:\QMK_MSYS\tmp\ccwyr4bu.s:1270   .bss.userUploadType:0000000000000000 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1272   .data.userAppAddr:0000000000000000 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1276   .data.userAppAddr:0000000000000000 userAppAddr
D:\QMK_MSYS\tmp\ccwyr4bu.s:1279   .data.userAppEnd:0000000000000000 $d
D:\QMK_MSYS\tmp\ccwyr4bu.s:1283   .data.userAppEnd:0000000000000000 userAppEnd

UNDEFINED SYMBOLS
nvicDisableInterrupts
usbEnbISR
systemHardReset
pInformation
flashErasePage
flashWriteWord
setupFLASH
flashUnlock
bkp10Write
getFlashEnd
flashLock
